["^ ","~:output",["^ ","~:js","goog.provide('clojure.core.rrb_vector.rrbt');\nclojure.core.rrb_vector.rrbt.rrbt_concat_threshold = (33);\nclojure.core.rrb_vector.rrbt.max_extra_search_steps = (2);\n\n/**\n * @interface\n */\nclojure.core.rrb_vector.rrbt.IVecImpl = function(){};\n\nvar clojure$core$rrb_vector$rrbt$IVecImpl$_tail_offset$dyn_10926 = (function (v){\nvar x__5350__auto__ = (((v == null))?null:v);\nvar m__5351__auto__ = (clojure.core.rrb_vector.rrbt._tail_offset[goog.typeOf(x__5350__auto__)]);\nif((!((m__5351__auto__ == null)))){\nreturn (m__5351__auto__.cljs$core$IFn$_invoke$arity$1 ? m__5351__auto__.cljs$core$IFn$_invoke$arity$1(v) : m__5351__auto__.call(null, v));\n} else {\nvar m__5349__auto__ = (clojure.core.rrb_vector.rrbt._tail_offset[\"_\"]);\nif((!((m__5349__auto__ == null)))){\nreturn (m__5349__auto__.cljs$core$IFn$_invoke$arity$1 ? m__5349__auto__.cljs$core$IFn$_invoke$arity$1(v) : m__5349__auto__.call(null, v));\n} else {\nthrow cljs.core.missing_protocol(\"IVecImpl.-tail-offset\",v);\n}\n}\n});\nclojure.core.rrb_vector.rrbt._tail_offset = (function clojure$core$rrb_vector$rrbt$_tail_offset(v){\nif((((!((v == null)))) && ((!((v.clojure$core$rrb_vector$rrbt$IVecImpl$_tail_offset$arity$1 == null)))))){\nreturn v.clojure$core$rrb_vector$rrbt$IVecImpl$_tail_offset$arity$1(v);\n} else {\nreturn clojure$core$rrb_vector$rrbt$IVecImpl$_tail_offset$dyn_10926(v);\n}\n});\n\nvar clojure$core$rrb_vector$rrbt$IVecImpl$_array_for$dyn_10928 = (function (v,i){\nvar x__5350__auto__ = (((v == null))?null:v);\nvar m__5351__auto__ = (clojure.core.rrb_vector.rrbt._array_for[goog.typeOf(x__5350__auto__)]);\nif((!((m__5351__auto__ == null)))){\nreturn (m__5351__auto__.cljs$core$IFn$_invoke$arity$2 ? m__5351__auto__.cljs$core$IFn$_invoke$arity$2(v,i) : m__5351__auto__.call(null, v,i));\n} else {\nvar m__5349__auto__ = (clojure.core.rrb_vector.rrbt._array_for[\"_\"]);\nif((!((m__5349__auto__ == null)))){\nreturn (m__5349__auto__.cljs$core$IFn$_invoke$arity$2 ? m__5349__auto__.cljs$core$IFn$_invoke$arity$2(v,i) : m__5349__auto__.call(null, v,i));\n} else {\nthrow cljs.core.missing_protocol(\"IVecImpl.-array-for\",v);\n}\n}\n});\nclojure.core.rrb_vector.rrbt._array_for = (function clojure$core$rrb_vector$rrbt$_array_for(v,i){\nif((((!((v == null)))) && ((!((v.clojure$core$rrb_vector$rrbt$IVecImpl$_array_for$arity$2 == null)))))){\nreturn v.clojure$core$rrb_vector$rrbt$IVecImpl$_array_for$arity$2(v,i);\n} else {\nreturn clojure$core$rrb_vector$rrbt$IVecImpl$_array_for$dyn_10928(v,i);\n}\n});\n\n\n/**\n * @interface\n */\nclojure.core.rrb_vector.rrbt.AsRRBT = function(){};\n\nvar clojure$core$rrb_vector$rrbt$AsRRBT$_as_rrbt$dyn_10929 = (function (v){\nvar x__5350__auto__ = (((v == null))?null:v);\nvar m__5351__auto__ = (clojure.core.rrb_vector.rrbt._as_rrbt[goog.typeOf(x__5350__auto__)]);\nif((!((m__5351__auto__ == null)))){\nreturn (m__5351__auto__.cljs$core$IFn$_invoke$arity$1 ? m__5351__auto__.cljs$core$IFn$_invoke$arity$1(v) : m__5351__auto__.call(null, v));\n} else {\nvar m__5349__auto__ = (clojure.core.rrb_vector.rrbt._as_rrbt[\"_\"]);\nif((!((m__5349__auto__ == null)))){\nreturn (m__5349__auto__.cljs$core$IFn$_invoke$arity$1 ? m__5349__auto__.cljs$core$IFn$_invoke$arity$1(v) : m__5349__auto__.call(null, v));\n} else {\nthrow cljs.core.missing_protocol(\"AsRRBT.-as-rrbt\",v);\n}\n}\n});\nclojure.core.rrb_vector.rrbt._as_rrbt = (function clojure$core$rrb_vector$rrbt$_as_rrbt(v){\nif((((!((v == null)))) && ((!((v.clojure$core$rrb_vector$rrbt$AsRRBT$_as_rrbt$arity$1 == null)))))){\nreturn v.clojure$core$rrb_vector$rrbt$AsRRBT$_as_rrbt$arity$1(v);\n} else {\nreturn clojure$core$rrb_vector$rrbt$AsRRBT$_as_rrbt$dyn_10929(v);\n}\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ASeq}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IChunkedNext}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.IPrintWithWriter}\n * @implements {cljs.core.IChunkedSeq}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\nclojure.core.rrb_vector.rrbt.RRBChunkedSeq = (function (vec,node,i,off,meta,__hash){\nthis.vec = vec;\nthis.node = node;\nthis.i = i;\nthis.off = off;\nthis.meta = meta;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 2179858668;\nthis.cljs$lang$protocol_mask$partition1$ = 1536;\n});\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n}));\n\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (this$,writer,opts){\nvar self__ = this;\nvar this$__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"(\",\" \",\")\",opts,this$__$1);\n}));\n\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.meta;\n}));\n\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$INext$_next$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif(((self__.off + (1)) < self__.node.length)){\nvar s = (function (){var G__10594 = self__.vec;\nvar G__10595 = self__.node;\nvar G__10596 = self__.i;\nvar G__10597 = (self__.off + (1));\nreturn (clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$4 ? clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$4(G__10594,G__10595,G__10596,G__10597) : clojure.core.rrb_vector.rrbt.rrb_chunked_seq.call(null, G__10594,G__10595,G__10596,G__10597));\n})();\nif((s == null)){\nreturn null;\n} else {\nreturn s;\n}\n} else {\nreturn coll__$1.cljs$core$IChunkedNext$_chunked_next$arity$1(null, );\n}\n}));\n\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar h__5111__auto__ = self__.__hash;\nif((!((h__5111__auto__ == null)))){\nreturn h__5111__auto__;\n} else {\nvar h__5111__auto____$1 = cljs.core.hash_ordered_coll(coll__$1);\n(self__.__hash = h__5111__auto____$1);\n\nreturn h__5111__auto____$1;\n}\n}));\n\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n}));\n\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.with_meta(cljs.core.List.EMPTY,self__.meta);\n}));\n\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (coll,f){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$2(cljs.core.subvec.cljs$core$IFn$_invoke$arity$3(self__.vec,(self__.i + self__.off),cljs.core.count(self__.vec)),f);\n}));\n\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (coll,f,start){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.subvec.cljs$core$IFn$_invoke$arity$3(self__.vec,(self__.i + self__.off),cljs.core.count(self__.vec)),f,start);\n}));\n\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$ISeq$_first$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (self__.node[self__.off]);\n}));\n\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$ISeq$_rest$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif(((self__.off + (1)) < self__.node.length)){\nvar s = (function (){var G__10606 = self__.vec;\nvar G__10607 = self__.node;\nvar G__10608 = self__.i;\nvar G__10609 = (self__.off + (1));\nreturn (clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$4 ? clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$4(G__10606,G__10607,G__10608,G__10609) : clojure.core.rrb_vector.rrbt.rrb_chunked_seq.call(null, G__10606,G__10607,G__10608,G__10609));\n})();\nif((s == null)){\nreturn cljs.core.List.EMPTY;\n} else {\nreturn s;\n}\n} else {\nreturn coll__$1.cljs$core$IChunkedSeq$_chunked_rest$arity$1(null, );\n}\n}));\n\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn coll__$1;\n}));\n\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$IChunkedSeq$_chunked_first$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.array_chunk.cljs$core$IFn$_invoke$arity$2(self__.node,self__.off);\n}));\n\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$IChunkedSeq$_chunked_rest$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar l = self__.node.length;\nvar s = ((((self__.i + l) < cljs.core._count(self__.vec)))?(function (){var G__10619 = self__.vec;\nvar G__10620 = (self__.i + l);\nvar G__10621 = (0);\nreturn (clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$3 ? clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$3(G__10619,G__10620,G__10621) : clojure.core.rrb_vector.rrbt.rrb_chunked_seq.call(null, G__10619,G__10620,G__10621));\n})():null);\nif((s == null)){\nreturn cljs.core.List.EMPTY;\n} else {\nreturn s;\n}\n}));\n\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,m){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$5 ? clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$5(self__.vec,self__.node,self__.i,self__.off,m) : clojure.core.rrb_vector.rrbt.rrb_chunked_seq.call(null, self__.vec,self__.node,self__.i,self__.off,m));\n}));\n\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,o){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.cons(o,coll__$1);\n}));\n\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$IChunkedNext$_chunked_next$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar l = self__.node.length;\nvar s = ((((self__.i + l) < cljs.core._count(self__.vec)))?(function (){var G__10626 = self__.vec;\nvar G__10627 = (self__.i + l);\nvar G__10628 = (0);\nreturn (clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$3 ? clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$3(G__10626,G__10627,G__10628) : clojure.core.rrb_vector.rrbt.rrb_chunked_seq.call(null, G__10626,G__10627,G__10628));\n})():null);\nif((s == null)){\nreturn null;\n} else {\nreturn s;\n}\n}));\n\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 6, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"vec\",\"vec\",982683596,null),new cljs.core.Symbol(null,\"node\",\"node\",-2073234571,null),new cljs.core.Symbol(null,\"i\",\"i\",253690212,null),new cljs.core.Symbol(null,\"off\",\"off\",-2047994980,null),new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"__hash\",\"__hash\",-1328796629,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n}));\n\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.cljs$lang$type = true);\n\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.cljs$lang$ctorStr = \"clojure.core.rrb-vector.rrbt/RRBChunkedSeq\");\n\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.cljs$lang$ctorPrWriter = (function (this__5287__auto__,writer__5288__auto__,opt__5289__auto__){\nreturn cljs.core._write(writer__5288__auto__,\"clojure.core.rrb-vector.rrbt/RRBChunkedSeq\");\n}));\n\n/**\n * Positional factory function for clojure.core.rrb-vector.rrbt/RRBChunkedSeq.\n */\nclojure.core.rrb_vector.rrbt.__GT_RRBChunkedSeq = (function clojure$core$rrb_vector$rrbt$__GT_RRBChunkedSeq(vec,node,i,off,meta,__hash){\nreturn (new clojure.core.rrb_vector.rrbt.RRBChunkedSeq(vec,node,i,off,meta,__hash));\n});\n\nclojure.core.rrb_vector.rrbt.rrb_chunked_seq = (function clojure$core$rrb_vector$rrbt$rrb_chunked_seq(var_args){\nvar G__10639 = arguments.length;\nswitch (G__10639) {\ncase 3:\nreturn clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 5:\nreturn clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$3 = (function (vec,i,off){\nreturn (new clojure.core.rrb_vector.rrbt.RRBChunkedSeq(vec,clojure.core.rrb_vector.rrbt._array_for(vec,i),i,off,null,null));\n}));\n\n(clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$4 = (function (vec,node,i,off){\nreturn (new clojure.core.rrb_vector.rrbt.RRBChunkedSeq(vec,node,i,off,null,null));\n}));\n\n(clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$5 = (function (vec,node,i,off,meta){\nreturn (new clojure.core.rrb_vector.rrbt.RRBChunkedSeq(vec,node,i,off,meta,null));\n}));\n\n(clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$lang$maxFixedArity = 5);\n\nclojure.core.rrb_vector.rrbt.slice_right = (function clojure$core$rrb_vector$rrbt$slice_right(node,shift,end){\nif((shift === (0))){\nvar arr = node.arr;\nvar new_arr = (new Array(end));\ncljs.core.array_copy(arr,(0),new_arr,(0),end);\n\nreturn cljs.core.__GT_VectorNode(null,new_arr);\n} else {\nvar reg_QMARK_ = clojure.core.rrb_vector.nodes.regular_QMARK_(node);\nvar rngs = (((!(reg_QMARK_)))?clojure.core.rrb_vector.nodes.node_ranges(node):null);\nvar i = (((end - (1)) >> shift) & (31));\nvar i__$1 = ((reg_QMARK_)?i:(function (){var j = i;\nwhile(true){\nif((end <= (rngs[j]))){\nreturn j;\n} else {\nvar G__10951 = (j + (1));\nj = G__10951;\ncontinue;\n}\nbreak;\n}\n})());\nvar child_end = ((reg_QMARK_)?(function (){var ce = cljs.core.mod(end,((1) << shift));\nif((ce === (0))){\nreturn ((1) << shift);\n} else {\nreturn ce;\n}\n})():(((i__$1 > (0)))?(end - (rngs[(i__$1 - (1))])):end));\nvar arr = node.arr;\nvar new_child = (function (){var G__10655 = (arr[i__$1]);\nvar G__10656 = (shift - (5));\nvar G__10657 = child_end;\nreturn (clojure.core.rrb_vector.rrbt.slice_right.cljs$core$IFn$_invoke$arity$3 ? clojure.core.rrb_vector.rrbt.slice_right.cljs$core$IFn$_invoke$arity$3(G__10655,G__10656,G__10657) : clojure.core.rrb_vector.rrbt.slice_right.call(null, G__10655,G__10656,G__10657));\n})();\nvar regular_child_QMARK_ = (((shift === (5)))?((32) === new_child.arr.length):clojure.core.rrb_vector.nodes.regular_QMARK_(new_child));\nvar new_arr = (new Array(((((reg_QMARK_) && (regular_child_QMARK_)))?(32):(33))));\nvar new_child_rng = ((regular_child_QMARK_)?(function (){var m = cljs.core.mod(child_end,((1) << shift));\nif((m === (0))){\nreturn ((1) << shift);\n} else {\nreturn m;\n}\n})():(((shift === (5)))?new_child.arr.length:clojure.core.rrb_vector.nodes.last_range(new_child)));\ncljs.core.array_copy(arr,(0),new_arr,(0),i__$1);\n\n(new_arr[i__$1] = new_child);\n\nif((!(((reg_QMARK_) && (regular_child_QMARK_))))){\nvar new_rngs_10954 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar step_10955 = ((1) << shift);\nif(reg_QMARK_){\nvar n__5593__auto___10956 = i__$1;\nvar j_10957 = (0);\nwhile(true){\nif((j_10957 < n__5593__auto___10956)){\n(new_rngs_10954[j_10957] = ((j_10957 + (1)) * step_10955));\n\nvar G__10958 = (j_10957 + (1));\nj_10957 = G__10958;\ncontinue;\n} else {\n}\nbreak;\n}\n} else {\nvar n__5593__auto___10959 = i__$1;\nvar j_10960 = (0);\nwhile(true){\nif((j_10960 < n__5593__auto___10959)){\n(new_rngs_10954[j_10960] = (rngs[j_10960]));\n\nvar G__10961 = (j_10960 + (1));\nj_10960 = G__10961;\ncontinue;\n} else {\n}\nbreak;\n}\n}\n\n(new_rngs_10954[i__$1] = ((((i__$1 > (0)))?(new_rngs_10954[(i__$1 - (1))]):(0)) + new_child_rng));\n\n(new_rngs_10954[(32)] = (i__$1 + (1)));\n\n(new_arr[(32)] = new_rngs_10954);\n} else {\n}\n\nreturn cljs.core.__GT_VectorNode(null,new_arr);\n}\n});\nclojure.core.rrb_vector.rrbt.slice_left = (function clojure$core$rrb_vector$rrbt$slice_left(node,shift,start,end){\nif((shift === (0))){\nvar arr = node.arr;\nvar new_len = (arr.length - start);\nvar new_arr = (new Array(new_len));\ncljs.core.array_copy(arr,start,new_arr,(0),new_len);\n\nreturn cljs.core.__GT_VectorNode(null,new_arr);\n} else {\nvar reg_QMARK_ = clojure.core.rrb_vector.nodes.regular_QMARK_(node);\nvar arr = node.arr;\nvar rngs = (((!(reg_QMARK_)))?clojure.core.rrb_vector.nodes.node_ranges(node):null);\nvar i = ((start >> shift) & (31));\nvar i__$1 = ((reg_QMARK_)?i:(function (){var j = i;\nwhile(true){\nif((start < (rngs[j]))){\nreturn j;\n} else {\nvar G__10969 = (j + (1));\nj = G__10969;\ncontinue;\n}\nbreak;\n}\n})());\nvar len = ((reg_QMARK_)?(function (){var i__$2 = i__$1;\nwhile(true){\nif((((i__$2 === (32))) || (((arr[i__$2]) == null)))){\nreturn i__$2;\n} else {\nvar G__10971 = (i__$2 + (1));\ni__$2 = G__10971;\ncontinue;\n}\nbreak;\n}\n})():(rngs[(32)]));\nvar child_start = (((i__$1 > (0)))?(start - ((reg_QMARK_)?(i__$1 * ((1) << shift)):(rngs[(i__$1 - (1))]))):start);\nvar child_end = ((reg_QMARK_)?(function (){var x__5090__auto__ = ((1) << shift);\nvar y__5091__auto__ = (((i__$1 > (0)))?(end - (i__$1 * ((1) << shift))):end);\nreturn ((x__5090__auto__ < y__5091__auto__) ? x__5090__auto__ : y__5091__auto__);\n})():(function (){var capped_end = (function (){var x__5090__auto__ = (rngs[i__$1]);\nvar y__5091__auto__ = end;\nreturn ((x__5090__auto__ < y__5091__auto__) ? x__5090__auto__ : y__5091__auto__);\n})();\nif((i__$1 > (0))){\nreturn (capped_end - (rngs[(i__$1 - (1))]));\n} else {\nreturn capped_end;\n}\n})());\nvar new_child = (function (){var G__10669 = (arr[i__$1]);\nvar G__10670 = (shift - (5));\nvar G__10671 = child_start;\nvar G__10672 = child_end;\nreturn (clojure.core.rrb_vector.rrbt.slice_left.cljs$core$IFn$_invoke$arity$4 ? clojure.core.rrb_vector.rrbt.slice_left.cljs$core$IFn$_invoke$arity$4(G__10669,G__10670,G__10671,G__10672) : clojure.core.rrb_vector.rrbt.slice_left.call(null, G__10669,G__10670,G__10671,G__10672));\n})();\nvar new_len = (len - i__$1);\nvar new_len__$1 = (((new_child == null))?(new_len - (1)):new_len);\nif((new_len__$1 === (0))){\nreturn null;\n} else {\nif(reg_QMARK_){\nvar new_arr = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar rngs__$1 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar rng0 = (((((new_child == null)) || ((((shift === (5))) || (clojure.core.rrb_vector.nodes.regular_QMARK_(new_child))))))?(((1) << shift) - ((start >> (shift - (5))) & (31))):clojure.core.rrb_vector.nodes.last_range(new_child));\nvar step = ((1) << shift);\nvar j_10982 = (0);\nvar r_10983 = rng0;\nwhile(true){\nif((j_10982 < new_len__$1)){\n(rngs__$1[j_10982] = r_10983);\n\nvar G__10984 = (j_10982 + (1));\nvar G__10985 = (r_10983 + step);\nj_10982 = G__10984;\nr_10983 = G__10985;\ncontinue;\n} else {\n}\nbreak;\n}\n\nif((new_len__$1 > (1))){\n(rngs__$1[(new_len__$1 - (1))] = (end - start));\n} else {\n}\n\n(rngs__$1[(32)] = new_len__$1);\n\ncljs.core.array_copy(arr,(((new_child == null))?(i__$1 + (1)):i__$1),new_arr,(0),new_len__$1);\n\nif((!((new_child == null)))){\n(new_arr[(0)] = new_child);\n} else {\n}\n\n(new_arr[(32)] = rngs__$1);\n\nreturn cljs.core.__GT_VectorNode(node.edit,new_arr);\n} else {\nvar new_arr = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar new_rngs = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar j_10986 = (0);\nvar i_10987__$2 = i__$1;\nwhile(true){\nif((j_10986 < new_len__$1)){\n(new_rngs[j_10986] = ((rngs[i_10987__$2]) - start));\n\nvar G__10988 = (j_10986 + (1));\nvar G__10989 = (i_10987__$2 + (1));\nj_10986 = G__10988;\ni_10987__$2 = G__10989;\ncontinue;\n} else {\n}\nbreak;\n}\n\n(new_rngs[(32)] = new_len__$1);\n\ncljs.core.array_copy(arr,(((new_child == null))?(i__$1 + (1)):i__$1),new_arr,(0),new_len__$1);\n\nif((!((new_child == null)))){\n(new_arr[(0)] = new_child);\n} else {\n}\n\n(new_arr[(32)] = new_rngs);\n\nreturn cljs.core.__GT_VectorNode(node.edit,new_arr);\n\n}\n}\n}\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IIndexed}\n * @implements {cljs.core.IVector}\n * @implements {cljs.core.IReversible}\n * @implements {cljs.core.IKVReduce}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEditableCollection}\n * @implements {clojure.core.rrb_vector.rrbt.AsRRBT}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {clojure.core.rrb_vector.protocols.PSliceableVector}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.IStack}\n * @implements {cljs.core.IMapEntry}\n * @implements {cljs.core.IPrintWithWriter}\n * @implements {cljs.core.IComparable}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IAssociative}\n * @implements {clojure.core.rrb_vector.protocols.PSpliceableVector}\n * @implements {clojure.core.rrb_vector.rrbt.IVecImpl}\n * @implements {cljs.core.ILookup}\n * @implements {cljs.core.IReduce}\n*/\nclojure.core.rrb_vector.rrbt.Vector = (function (cnt,shift,root,tail,meta,__hash){\nthis.cnt = cnt;\nthis.shift = shift;\nthis.root = root;\nthis.tail = tail;\nthis.meta = meta;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 2315152159;\nthis.cljs$lang$protocol_mask$partition1$ = 2052;\n});\n(clojure.core.rrb_vector.rrbt.Vector.prototype.toString = (function (){\nvar self__ = this;\nvar this$ = this;\nreturn cljs.core.pr_str_STAR_(this$);\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$ILookup$_lookup$arity$2 = (function (this$,k){\nvar self__ = this;\nvar this$__$1 = this;\nreturn this$__$1.cljs$core$IIndexed$_nth$arity$3(null, k,null);\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$ILookup$_lookup$arity$3 = (function (this$,k,not_found){\nvar self__ = this;\nvar this$__$1 = this;\nreturn this$__$1.cljs$core$IIndexed$_nth$arity$3(null, k,not_found);\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IKVReduce$_kv_reduce$arity$3 = (function (this$,f,init){\nvar self__ = this;\nvar this$__$1 = this;\nif((self__.cnt === (0))){\nreturn init;\n} else {\nvar i = (0);\nvar j = (0);\nvar init__$1 = init;\nvar arr = this$__$1.clojure$core$rrb_vector$rrbt$IVecImpl$_array_for$arity$2(null, i);\nvar lim = (arr.length - (1));\nvar step = (lim + (1));\nwhile(true){\nvar init__$2 = (function (){var G__10699 = init__$1;\nvar G__10700 = (i + j);\nvar G__10701 = (arr[j]);\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__10699,G__10700,G__10701) : f.call(null, G__10699,G__10700,G__10701));\n})();\nif(cljs.core.reduced_QMARK_(init__$2)){\nreturn cljs.core.deref(init__$2);\n} else {\nif((j < lim)){\nvar G__10995 = i;\nvar G__10996 = (j + (1));\nvar G__10997 = init__$2;\nvar G__10998 = arr;\nvar G__10999 = lim;\nvar G__11000 = step;\ni = G__10995;\nj = G__10996;\ninit__$1 = G__10997;\narr = G__10998;\nlim = G__10999;\nstep = G__11000;\ncontinue;\n} else {\nvar i__$1 = (i + step);\nif((i__$1 < self__.cnt)){\nvar arr__$1 = this$__$1.clojure$core$rrb_vector$rrbt$IVecImpl$_array_for$arity$2(null, i__$1);\nvar len = arr__$1.length;\nvar lim__$1 = (len - (1));\nvar G__11001 = i__$1;\nvar G__11002 = (0);\nvar G__11003 = init__$2;\nvar G__11004 = arr__$1;\nvar G__11005 = lim__$1;\nvar G__11006 = len;\ni = G__11001;\nj = G__11002;\ninit__$1 = G__11003;\narr = G__11004;\nlim = G__11005;\nstep = G__11006;\ncontinue;\n} else {\nreturn init__$2;\n}\n}\n}\nbreak;\n}\n}\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IIndexed$_nth$arity$2 = (function (this$,i){\nvar self__ = this;\nvar this$__$1 = this;\nif(((((0) <= i)) && ((i < self__.cnt)))){\nvar tail_off = (self__.cnt - self__.tail.length);\nif((tail_off <= i)){\nreturn (self__.tail[(i - tail_off)]);\n} else {\nvar i__$1 = i;\nvar node = self__.root;\nvar shift__$1 = self__.shift;\nwhile(true){\nif((shift__$1 === (0))){\nvar arr = node.arr;\nreturn (arr[((i__$1 >> shift__$1) & (31))]);\n} else {\nif(clojure.core.rrb_vector.nodes.regular_QMARK_(node)){\nvar arr = node.arr;\nvar idx = ((i__$1 >> shift__$1) & (31));\nvar i__$2 = i__$1;\nvar node__$1 = (arr[idx]);\nvar shift__$2 = (shift__$1 - (5));\nwhile(true){\nvar arr__$1 = node__$1.arr;\nvar idx__$1 = ((i__$2 >> shift__$2) & (31));\nif((shift__$2 === (0))){\nreturn (arr__$1[idx__$1]);\n} else {\nvar G__11011 = i__$2;\nvar G__11012 = (arr__$1[idx__$1]);\nvar G__11013 = (shift__$2 - (5));\ni__$2 = G__11011;\nnode__$1 = G__11012;\nshift__$2 = G__11013;\ncontinue;\n}\nbreak;\n}\n} else {\nvar arr = node.arr;\nvar rngs = clojure.core.rrb_vector.nodes.node_ranges(node);\nvar idx = (function (){var j = ((i__$1 >> shift__$1) & (31));\nwhile(true){\nif((i__$1 < (rngs[j]))){\nreturn j;\n} else {\nvar G__11016 = (j + (1));\nj = G__11016;\ncontinue;\n}\nbreak;\n}\n})();\nvar i__$2 = (((idx === (0)))?i__$1:(i__$1 - (rngs[(idx - (1))])));\nvar G__11018 = i__$2;\nvar G__11019 = (arr[idx]);\nvar G__11020 = (shift__$1 - (5));\ni__$1 = G__11018;\nnode = G__11019;\nshift__$1 = G__11020;\ncontinue;\n}\n}\nbreak;\n}\n}\n} else {\nreturn cljs.core.vector_index_out_of_bounds(i,self__.cnt);\n}\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IIndexed$_nth$arity$3 = (function (this$,i,not_found){\nvar self__ = this;\nvar this$__$1 = this;\nif((((i >= (0))) && ((i < self__.cnt)))){\nreturn this$__$1.cljs$core$IIndexed$_nth$arity$2(null, i);\n} else {\nreturn not_found;\n}\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (this$,writer,opts){\nvar self__ = this;\nvar this$__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"[\",\" \",\"]\",opts,this$__$1);\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IVector$_assoc_n$arity$3 = (function (this$,i,val){\nvar self__ = this;\nvar this$__$1 = this;\nif(((((0) <= i)) && ((i < self__.cnt)))){\nvar tail_off = this$__$1.clojure$core$rrb_vector$rrbt$IVecImpl$_tail_offset$arity$1(null, );\nif((i >= tail_off)){\nvar new_tail = (new Array(self__.tail.length));\nvar idx = (i - tail_off);\ncljs.core.array_copy(self__.tail,(0),new_tail,(0),self__.tail.length);\n\n(new_tail[idx] = val);\n\nreturn (new clojure.core.rrb_vector.rrbt.Vector(self__.cnt,self__.shift,self__.root,new_tail,self__.meta,null));\n} else {\nreturn (new clojure.core.rrb_vector.rrbt.Vector(self__.cnt,self__.shift,clojure.core.rrb_vector.trees.do_assoc(self__.shift,self__.root,i,val),self__.tail,self__.meta,null));\n}\n} else {\nif((i === self__.cnt)){\nreturn this$__$1.cljs$core$ICollection$_conj$arity$2(null, val);\n} else {\nreturn cljs.core.vector_index_out_of_bounds(i,self__.cnt);\n\n}\n}\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.clojure$core$rrb_vector$rrbt$AsRRBT$ = cljs.core.PROTOCOL_SENTINEL);\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.clojure$core$rrb_vector$rrbt$AsRRBT$_as_rrbt$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nreturn this$__$1;\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IMeta$_meta$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nreturn self__.meta;\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$ICounted$_count$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn self__.cnt;\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IMapEntry$_key$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nreturn this$__$1.cljs$core$IIndexed$_nth$arity$2(null, (0));\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IMapEntry$_val$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nreturn this$__$1.cljs$core$IIndexed$_nth$arity$2(null, (1));\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IStack$_peek$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nif((self__.cnt > (0))){\nreturn this$__$1.cljs$core$IIndexed$_nth$arity$2(null, (self__.cnt - (1)));\n} else {\nreturn null;\n}\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IStack$_pop$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nif((self__.cnt === (0))){\nthrow (new Error(\"Can't pop empty vector\"));\n} else {\nif(((1) === self__.cnt)){\nreturn cljs.core._with_meta(cljs.core.PersistentVector.EMPTY,self__.meta);\n} else {\nif((self__.tail.length > (1))){\nvar new_tail = (new Array((self__.tail.length - (1))));\ncljs.core.array_copy(self__.tail,(0),new_tail,(0),new_tail.length);\n\nreturn (new clojure.core.rrb_vector.rrbt.Vector((self__.cnt - (1)),self__.shift,self__.root,new_tail,self__.meta,null));\n} else {\nvar new_tail = this$__$1.clojure$core$rrb_vector$rrbt$IVecImpl$_array_for$arity$2(null, (self__.cnt - (2)));\nvar root_cnt = this$__$1.clojure$core$rrb_vector$rrbt$IVecImpl$_tail_offset$arity$1(null, );\nvar new_root = clojure.core.rrb_vector.trees.pop_tail(self__.shift,root_cnt,self__.root.edit,self__.root);\nif((new_root == null)){\nreturn (new clojure.core.rrb_vector.rrbt.Vector((self__.cnt - (1)),self__.shift,clojure.core.rrb_vector.nodes.empty_node,new_tail,self__.meta,null));\n} else {\nif((((self__.shift > (5))) && (((new_root.arr[(1)]) == null)))){\nreturn (new clojure.core.rrb_vector.rrbt.Vector((self__.cnt - (1)),(self__.shift - (5)),(new_root.arr[(0)]),new_tail,self__.meta,null));\n} else {\nreturn (new clojure.core.rrb_vector.rrbt.Vector((self__.cnt - (1)),self__.shift,new_root,new_tail,self__.meta,null));\n\n}\n}\n\n}\n}\n}\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IReversible$_rseq$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nif((self__.cnt > (0))){\nreturn (new cljs.core.RSeq(this$__$1,(self__.cnt - (1)),null));\n} else {\nreturn null;\n}\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IHash$_hash$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nvar h__5111__auto__ = self__.__hash;\nif((!((h__5111__auto__ == null)))){\nreturn h__5111__auto__;\n} else {\nvar h__5111__auto____$1 = cljs.core.hash_ordered_coll(this$__$1);\n(self__.__hash = h__5111__auto____$1);\n\nreturn h__5111__auto____$1;\n}\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (this$,that){\nvar self__ = this;\nvar this$__$1 = this;\nreturn cljs.core.equiv_sequential(this$__$1,that);\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IEditableCollection$_as_transient$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nvar G__10717 = self__.cnt;\nvar G__10718 = self__.shift;\nvar G__10719 = clojure.core.rrb_vector.transients.editable_root(self__.root);\nvar G__10720 = clojure.core.rrb_vector.transients.editable_tail(self__.tail);\nvar G__10721 = self__.tail.length;\nreturn (clojure.core.rrb_vector.rrbt.__GT_Transient.cljs$core$IFn$_invoke$arity$5 ? clojure.core.rrb_vector.rrbt.__GT_Transient.cljs$core$IFn$_invoke$arity$5(G__10717,G__10718,G__10719,G__10720,G__10721) : clojure.core.rrb_vector.rrbt.__GT_Transient.call(null, G__10717,G__10718,G__10719,G__10720,G__10721));\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn cljs.core.with_meta(cljs.core.PersistentVector.EMPTY,self__.meta);\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.clojure$core$rrb_vector$protocols$PSliceableVector$ = cljs.core.PROTOCOL_SENTINEL);\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.clojure$core$rrb_vector$protocols$PSliceableVector$_slicev$arity$3 = (function (this$,start,end){\nvar self__ = this;\nvar this$__$1 = this;\nvar new_cnt = (end - start);\nif((((start < (0))) || ((end > self__.cnt)))){\nthrow (new Error(\"vector index out of bounds\"));\n} else {\nif((start === end)){\nreturn cljs.core.empty(this$__$1);\n} else {\nif((start > end)){\nthrow (new Error(\"start index greater than end index\"));\n} else {\nvar tail_off = this$__$1.clojure$core$rrb_vector$rrbt$IVecImpl$_tail_offset$arity$1(null, );\nif((start >= tail_off)){\nvar new_tail = (new Array(new_cnt));\ncljs.core.array_copy(self__.tail,(start - tail_off),new_tail,(0),new_cnt);\n\nreturn (new clojure.core.rrb_vector.rrbt.Vector(new_cnt,(5),clojure.core.rrb_vector.nodes.empty_node,new_tail,self__.meta,null));\n} else {\nvar tail_cut_QMARK_ = (end > tail_off);\nvar new_root = ((tail_cut_QMARK_)?self__.root:clojure.core.rrb_vector.rrbt.slice_right(self__.root,self__.shift,end));\nvar new_root__$1 = (((start === (0)))?new_root:clojure.core.rrb_vector.rrbt.slice_left(new_root,self__.shift,start,(function (){var x__5090__auto__ = end;\nvar y__5091__auto__ = tail_off;\nreturn ((x__5090__auto__ < y__5091__auto__) ? x__5090__auto__ : y__5091__auto__);\n})()));\nvar new_tail = ((tail_cut_QMARK_)?(function (){var new_len = (end - tail_off);\nvar new_tail = (new Array(new_len));\ncljs.core.array_copy(self__.tail,(0),new_tail,(0),new_len);\n\nreturn new_tail;\n})():(new clojure.core.rrb_vector.rrbt.Vector(new_cnt,self__.shift,new_root__$1,[],self__.meta,null)).clojure$core$rrb_vector$rrbt$IVecImpl$_array_for$arity$2(null, (new_cnt - (1))));\nvar new_root__$2 = ((tail_cut_QMARK_)?new_root__$1:clojure.core.rrb_vector.trees.pop_tail(self__.shift,new_cnt,new_root__$1.edit,new_root__$1));\nif((new_root__$2 == null)){\nreturn (new clojure.core.rrb_vector.rrbt.Vector(new_cnt,(5),clojure.core.rrb_vector.nodes.empty_node,new_tail,self__.meta,null));\n} else {\nvar r = new_root__$2;\nvar s = self__.shift;\nwhile(true){\nif((((s > (5))) && (((r.arr[(1)]) == null)))){\nvar G__11040 = (r.arr[(0)]);\nvar G__11041 = (s - (5));\nr = G__11040;\ns = G__11041;\ncontinue;\n} else {\nreturn (new clojure.core.rrb_vector.rrbt.Vector(new_cnt,s,r,new_tail,self__.meta,null));\n}\nbreak;\n}\n}\n}\n\n}\n}\n}\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.clojure$core$rrb_vector$rrbt$IVecImpl$ = cljs.core.PROTOCOL_SENTINEL);\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.clojure$core$rrb_vector$rrbt$IVecImpl$_tail_offset$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nreturn (self__.cnt - self__.tail.length);\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.clojure$core$rrb_vector$rrbt$IVecImpl$_array_for$arity$2 = (function (this$,i){\nvar self__ = this;\nvar this$__$1 = this;\nif(((((0) <= i)) && ((i < self__.cnt)))){\nif((i >= this$__$1.clojure$core$rrb_vector$rrbt$IVecImpl$_tail_offset$arity$1(null, ))){\nreturn self__.tail;\n} else {\nvar i__$1 = i;\nvar node = self__.root;\nvar shift__$1 = self__.shift;\nwhile(true){\nif((shift__$1 === (0))){\nreturn node.arr;\n} else {\nif(clojure.core.rrb_vector.nodes.regular_QMARK_(node)){\nvar node__$1 = (node.arr[((i__$1 >> shift__$1) & (31))]);\nvar shift__$2 = (shift__$1 - (5));\nwhile(true){\nif((shift__$2 === (0))){\nreturn node__$1.arr;\n} else {\nvar G__11048 = (node__$1.arr[((i__$1 >> shift__$2) & (31))]);\nvar G__11049 = (shift__$2 - (5));\nnode__$1 = G__11048;\nshift__$2 = G__11049;\ncontinue;\n}\nbreak;\n}\n} else {\nvar rngs = clojure.core.rrb_vector.nodes.node_ranges(node);\nvar j = (function (){var j = ((i__$1 >> shift__$1) & (31));\nwhile(true){\nif((i__$1 < (rngs[j]))){\nreturn j;\n} else {\nvar G__11052 = (j + (1));\nj = G__11052;\ncontinue;\n}\nbreak;\n}\n})();\nvar i__$2 = (((j > (0)))?(i__$1 - (rngs[(j - (1))])):i__$1);\nvar G__11054 = i__$2;\nvar G__11055 = (node.arr[j]);\nvar G__11056 = (shift__$1 - (5));\ni__$1 = G__11054;\nnode = G__11055;\nshift__$1 = G__11056;\ncontinue;\n}\n}\nbreak;\n}\n}\n} else {\nreturn cljs.core.vector_index_out_of_bounds(i,self__.cnt);\n}\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (this$,f){\nvar self__ = this;\nvar this$__$1 = this;\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$2(this$__$1,f);\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (this$,f,start){\nvar self__ = this;\nvar this$__$1 = this;\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$3(this$__$1,f,start);\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IAssociative$_assoc$arity$3 = (function (this$,k,v){\nvar self__ = this;\nvar this$__$1 = this;\nreturn this$__$1.cljs$core$IVector$_assoc_n$arity$3(null, k,v);\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nif((self__.cnt === (0))){\nreturn null;\n} else {\nif((this$__$1.clojure$core$rrb_vector$rrbt$IVecImpl$_tail_offset$arity$1(null, ) === (0))){\nreturn cljs.core.array_seq.cljs$core$IFn$_invoke$arity$1(self__.tail);\n} else {\nreturn clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$3(this$__$1,(0),(0));\n\n}\n}\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (this$,meta__$1){\nvar self__ = this;\nvar this$__$1 = this;\nreturn (new clojure.core.rrb_vector.rrbt.Vector(self__.cnt,self__.shift,self__.root,self__.tail,meta__$1,self__.__hash));\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$ICollection$_conj$arity$2 = (function (this$,val){\nvar self__ = this;\nvar this$__$1 = this;\nif((self__.tail.length < (32))){\nvar tail_len = self__.tail.length;\nvar new_tail = (new Array((tail_len + (1))));\ncljs.core.array_copy(self__.tail,(0),new_tail,(0),tail_len);\n\n(new_tail[tail_len] = val);\n\nreturn (new clojure.core.rrb_vector.rrbt.Vector((self__.cnt + (1)),self__.shift,self__.root,new_tail,self__.meta,null));\n} else {\nvar tail_node = cljs.core.__GT_VectorNode(self__.root.edit,self__.tail);\nvar new_tail = (function (){var new_arr = [null];\n(new_arr[(0)] = val);\n\nreturn new_arr;\n})();\nif(clojure.core.rrb_vector.nodes.overflow_QMARK_(self__.root,self__.shift,self__.cnt)){\nif(clojure.core.rrb_vector.nodes.regular_QMARK_(self__.root)){\nvar new_arr = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar new_root = cljs.core.__GT_VectorNode(self__.root.edit,new_arr);\nvar G__10739_11091 = new_arr;\n(G__10739_11091[(0)] = self__.root);\n\n(G__10739_11091[(1)] = clojure.core.rrb_vector.trees.new_path(self__.tail,self__.root.edit,self__.shift,tail_node));\n\n\nreturn (new clojure.core.rrb_vector.rrbt.Vector((self__.cnt + (1)),(self__.shift + (5)),new_root,new_tail,self__.meta,null));\n} else {\nvar new_arr = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar new_rngs = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar new_root = cljs.core.__GT_VectorNode(self__.root.edit,new_arr);\nvar root_total_range = (clojure.core.rrb_vector.nodes.node_ranges(self__.root)[(31)]);\nvar G__10741_11094 = new_arr;\n(G__10741_11094[(0)] = self__.root);\n\n(G__10741_11094[(1)] = clojure.core.rrb_vector.trees.new_path(self__.tail,self__.root.edit,self__.shift,tail_node));\n\n(G__10741_11094[(32)] = new_rngs);\n\n\nvar G__10742_11100 = new_rngs;\n(G__10742_11100[(0)] = root_total_range);\n\n(G__10742_11100[(1)] = (root_total_range + (32)));\n\n(G__10742_11100[(32)] = (2));\n\n\nreturn (new clojure.core.rrb_vector.rrbt.Vector((self__.cnt + (1)),(self__.shift + (5)),new_root,new_tail,self__.meta,null));\n}\n} else {\nreturn (new clojure.core.rrb_vector.rrbt.Vector((self__.cnt + (1)),self__.shift,clojure.core.rrb_vector.trees.push_tail(self__.shift,self__.cnt,self__.root.edit,self__.root,tail_node),new_tail,self__.meta,null));\n}\n}\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.call = (function (unused__10318__auto__){\nvar self__ = this;\nvar self__ = this;\nvar G__10747 = (arguments.length - (1));\nswitch (G__10747) {\ncase (1):\nreturn self__.cljs$core$IFn$_invoke$arity$1((arguments[(1)]));\n\nbreak;\ncase (2):\nreturn self__.cljs$core$IFn$_invoke$arity$2((arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1((arguments.length - (1)))].join('')));\n\n}\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.apply = (function (self__,args10695){\nvar self__ = this;\nvar self____$1 = this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args10695)));\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IFn$_invoke$arity$1 = (function (k){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IIndexed$_nth$arity$2(null, k);\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IFn$_invoke$arity$2 = (function (k,not_found){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IIndexed$_nth$arity$3(null, k,not_found);\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IComparable$_compare$arity$2 = (function (this$,that){\nvar self__ = this;\nvar this$__$1 = this;\nreturn cljs.core.compare_indexed.cljs$core$IFn$_invoke$arity$2(this$__$1,that);\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.clojure$core$rrb_vector$protocols$PSpliceableVector$ = cljs.core.PROTOCOL_SENTINEL);\n\n(clojure.core.rrb_vector.rrbt.Vector.prototype.clojure$core$rrb_vector$protocols$PSpliceableVector$_splicev$arity$2 = (function (this$,that){\nvar self__ = this;\nvar this$__$1 = this;\nvar G__10748 = this$__$1;\nvar G__10749 = clojure.core.rrb_vector.rrbt._as_rrbt(that);\nreturn (clojure.core.rrb_vector.rrbt.splice_rrbts.cljs$core$IFn$_invoke$arity$2 ? clojure.core.rrb_vector.rrbt.splice_rrbts.cljs$core$IFn$_invoke$arity$2(G__10748,G__10749) : clojure.core.rrb_vector.rrbt.splice_rrbts.call(null, G__10748,G__10749));\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 6, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"cnt\",\"cnt\",1924510325,null),new cljs.core.Symbol(null,\"shift\",\"shift\",-1657295705,null),new cljs.core.Symbol(null,\"root\",\"root\",1191874074,null),new cljs.core.Symbol(null,\"tail\",\"tail\",494507963,null),new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"__hash\",\"__hash\",-1328796629,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n}));\n\n(clojure.core.rrb_vector.rrbt.Vector.cljs$lang$type = true);\n\n(clojure.core.rrb_vector.rrbt.Vector.cljs$lang$ctorStr = \"clojure.core.rrb-vector.rrbt/Vector\");\n\n(clojure.core.rrb_vector.rrbt.Vector.cljs$lang$ctorPrWriter = (function (this__5287__auto__,writer__5288__auto__,opt__5289__auto__){\nreturn cljs.core._write(writer__5288__auto__,\"clojure.core.rrb-vector.rrbt/Vector\");\n}));\n\n/**\n * Positional factory function for clojure.core.rrb-vector.rrbt/Vector.\n */\nclojure.core.rrb_vector.rrbt.__GT_Vector = (function clojure$core$rrb_vector$rrbt$__GT_Vector(cnt,shift,root,tail,meta,__hash){\nreturn (new clojure.core.rrb_vector.rrbt.Vector(cnt,shift,root,tail,meta,__hash));\n});\n\n(cljs.core.PersistentVector.prototype.clojure$core$rrb_vector$rrbt$AsRRBT$ = cljs.core.PROTOCOL_SENTINEL);\n\n(cljs.core.PersistentVector.prototype.clojure$core$rrb_vector$rrbt$AsRRBT$_as_rrbt$arity$1 = (function (this$){\nvar this$__$1 = this;\nreturn (new clojure.core.rrb_vector.rrbt.Vector(cljs.core.count(this$__$1),this$__$1.shift,this$__$1.root,this$__$1.tail,cljs.core.meta(this$__$1),null));\n}));\n\n(cljs.core.Subvec.prototype.clojure$core$rrb_vector$rrbt$AsRRBT$ = cljs.core.PROTOCOL_SENTINEL);\n\n(cljs.core.Subvec.prototype.clojure$core$rrb_vector$rrbt$AsRRBT$_as_rrbt$arity$1 = (function (this$){\nvar this$__$1 = this;\nvar v = this$__$1.v;\nvar start = this$__$1.start;\nvar end = this$__$1.end;\nreturn clojure.core.rrb_vector.protocols._slicev(clojure.core.rrb_vector.rrbt._as_rrbt(v),start,end);\n}));\nclojure.core.rrb_vector.rrbt.shift_from_to = (function clojure$core$rrb_vector$rrbt$shift_from_to(node,from,to){\nwhile(true){\nif((from === to)){\nreturn node;\n} else {\nif(clojure.core.rrb_vector.nodes.regular_QMARK_(node)){\nvar G__11117 = cljs.core.__GT_VectorNode(node.edit,(function (){var G__10766 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\n(G__10766[(0)] = node);\n\nreturn G__10766;\n})());\nvar G__11118 = ((5) + from);\nvar G__11119 = to;\nnode = G__11117;\nfrom = G__11118;\nto = G__11119;\ncontinue;\n} else {\nvar G__11122 = cljs.core.__GT_VectorNode(node.edit,(function (){var G__10767 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\n(G__10767[(0)] = node);\n\n(G__10767[(32)] = (function (){var G__10768 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\n(G__10768[(0)] = clojure.core.rrb_vector.nodes.last_range(node));\n\n(G__10768[(32)] = (1));\n\nreturn G__10768;\n})());\n\nreturn G__10767;\n})());\nvar G__11123 = ((5) + from);\nvar G__11124 = to;\nnode = G__11122;\nfrom = G__11123;\nto = G__11124;\ncontinue;\n\n}\n}\nbreak;\n}\n});\nclojure.core.rrb_vector.rrbt.slot_count = (function clojure$core$rrb_vector$rrbt$slot_count(node,shift){\nvar arr = node.arr;\nif((shift === (0))){\nreturn arr.length;\n} else {\nif(clojure.core.rrb_vector.nodes.regular_QMARK_(node)){\nreturn clojure.core.rrb_vector.nodes.index_of_nil(arr);\n} else {\nvar rngs = clojure.core.rrb_vector.nodes.node_ranges(node);\nreturn (rngs[(32)]);\n}\n}\n});\nclojure.core.rrb_vector.rrbt.subtree_branch_count = (function clojure$core$rrb_vector$rrbt$subtree_branch_count(node,shift){\nvar arr = node.arr;\nvar cs = (shift - (5));\nif(clojure.core.rrb_vector.nodes.regular_QMARK_(node)){\nvar i = (0);\nvar sbc = (0);\nwhile(true){\nif((i === (32))){\nreturn sbc;\n} else {\nvar temp__5802__auto__ = (arr[i]);\nif(cljs.core.truth_(temp__5802__auto__)){\nvar child = temp__5802__auto__;\nvar G__11130 = (i + (1));\nvar G__11131 = (sbc + clojure.core.rrb_vector.rrbt.slot_count(child,cs));\ni = G__11130;\nsbc = G__11131;\ncontinue;\n} else {\nreturn sbc;\n}\n}\nbreak;\n}\n} else {\nvar lim = (clojure.core.rrb_vector.nodes.node_ranges(node)[(32)]);\nvar i = (0);\nvar sbc = (0);\nwhile(true){\nif((i === lim)){\nreturn sbc;\n} else {\nvar child = (arr[i]);\nvar G__11164 = (i + (1));\nvar G__11165 = (sbc + clojure.core.rrb_vector.rrbt.slot_count(child,cs));\ni = G__11164;\nsbc = G__11165;\ncontinue;\n}\nbreak;\n}\n}\n});\nclojure.core.rrb_vector.rrbt.leaf_seq = (function clojure$core$rrb_vector$rrbt$leaf_seq(arr){\nreturn cljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic((function (p1__10779_SHARP_){\nreturn p1__10779_SHARP_.arr;\n}),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.take.cljs$core$IFn$_invoke$arity$2(clojure.core.rrb_vector.nodes.index_of_nil(arr),arr)], 0));\n});\nclojure.core.rrb_vector.rrbt.rebalance_leaves = (function clojure$core$rrb_vector$rrbt$rebalance_leaves(n1,cnt1,n2,cnt2,transferred_leaves){\nvar slc1 = clojure.core.rrb_vector.rrbt.slot_count(n1,(5));\nvar slc2 = clojure.core.rrb_vector.rrbt.slot_count(n2,(5));\nvar a = (slc1 + slc2);\nvar sbc1 = clojure.core.rrb_vector.rrbt.subtree_branch_count(n1,(5));\nvar sbc2 = clojure.core.rrb_vector.rrbt.subtree_branch_count(n2,(5));\nvar p = (sbc1 + sbc2);\nvar e = (a - (cljs.core.quot((p - (1)),(32)) + (1)));\nif((e <= (2))){\nreturn [n1,n2];\n} else {\nif(((sbc1 + sbc2) <= (1024))){\nvar reg_QMARK_ = (cljs.core.mod(p,(32)) === (0));\nvar new_arr = (new Array(((reg_QMARK_)?(32):(33))));\nvar new_n1 = cljs.core.__GT_VectorNode(null,new_arr);\nvar i_11185 = (0);\nvar bs_11186 = cljs.core.partition_all.cljs$core$IFn$_invoke$arity$2((32),cljs.core.concat.cljs$core$IFn$_invoke$arity$2(clojure.core.rrb_vector.rrbt.leaf_seq(n1.arr),clojure.core.rrb_vector.rrbt.leaf_seq(n2.arr)));\nwhile(true){\nvar temp__5804__auto___11195 = cljs.core.seq(bs_11186);\nif(temp__5804__auto___11195){\nvar xs__6360__auto___11196 = temp__5804__auto___11195;\nvar block_11197 = cljs.core.first(xs__6360__auto___11196);\nvar a_11199__$1 = (new Array(cljs.core.count(block_11197)));\nvar i_11201__$1 = (0);\nvar xs_11202 = cljs.core.seq(block_11197);\nwhile(true){\nif(xs_11202){\n(a_11199__$1[i_11201__$1] = cljs.core.first(xs_11202));\n\nvar G__11203 = (i_11201__$1 + (1));\nvar G__11204 = cljs.core.next(xs_11202);\ni_11201__$1 = G__11203;\nxs_11202 = G__11204;\ncontinue;\n} else {\n}\nbreak;\n}\n\n(new_arr[i_11185] = cljs.core.__GT_VectorNode(null,a_11199__$1));\n\nvar G__11205 = (i_11185 + (1));\nvar G__11206 = cljs.core.next(bs_11186);\ni_11185 = G__11205;\nbs_11186 = G__11206;\ncontinue;\n} else {\n}\nbreak;\n}\n\nif((!(reg_QMARK_))){\n(new_arr[(32)] = clojure.core.rrb_vector.nodes.regular_ranges((5),p));\n} else {\n}\n\n(transferred_leaves.val = sbc2);\n\nreturn [new_n1,null];\n} else {\nvar reg_QMARK_ = (cljs.core.mod(p,(32)) === (0));\nvar new_arr1 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar new_arr2 = (new Array(((reg_QMARK_)?(32):(33))));\nvar new_n1 = cljs.core.__GT_VectorNode(null,new_arr1);\nvar new_n2 = cljs.core.__GT_VectorNode(null,new_arr2);\nvar i_11209 = (0);\nvar bs_11210 = cljs.core.partition_all.cljs$core$IFn$_invoke$arity$2((32),cljs.core.concat.cljs$core$IFn$_invoke$arity$2(clojure.core.rrb_vector.rrbt.leaf_seq(n1.arr),clojure.core.rrb_vector.rrbt.leaf_seq(n2.arr)));\nwhile(true){\nvar temp__5804__auto___11211 = cljs.core.seq(bs_11210);\nif(temp__5804__auto___11211){\nvar xs__6360__auto___11213 = temp__5804__auto___11211;\nvar block_11214 = cljs.core.first(xs__6360__auto___11213);\nvar a_11218__$1 = (new Array(cljs.core.count(block_11214)));\nvar i_11219__$1 = (0);\nvar xs_11220 = cljs.core.seq(block_11214);\nwhile(true){\nif(xs_11220){\n(a_11218__$1[i_11219__$1] = cljs.core.first(xs_11220));\n\nvar G__11221 = (i_11219__$1 + (1));\nvar G__11222 = cljs.core.next(xs_11220);\ni_11219__$1 = G__11221;\nxs_11220 = G__11222;\ncontinue;\n} else {\n}\nbreak;\n}\n\nif((i_11209 < (32))){\n(new_arr1[i_11209] = cljs.core.__GT_VectorNode(null,a_11218__$1));\n} else {\n(new_arr2[(i_11209 - (32))] = cljs.core.__GT_VectorNode(null,a_11218__$1));\n}\n\nvar G__11223 = (i_11209 + (1));\nvar G__11224 = cljs.core.next(bs_11210);\ni_11209 = G__11223;\nbs_11210 = G__11224;\ncontinue;\n} else {\n}\nbreak;\n}\n\nif((!(reg_QMARK_))){\n(new_arr2[(32)] = clojure.core.rrb_vector.nodes.regular_ranges((5),(p - (1024))));\n} else {\n}\n\n(transferred_leaves.val = ((1024) - sbc1));\n\nreturn [new_n1,new_n2];\n\n}\n}\n});\nclojure.core.rrb_vector.rrbt.child_seq = (function clojure$core$rrb_vector$rrbt$child_seq(node,shift,cnt){\nvar arr = node.arr;\nvar rngs = ((clojure.core.rrb_vector.nodes.regular_QMARK_(node))?clojure.core.rrb_vector.nodes.regular_ranges(shift,cnt):clojure.core.rrb_vector.nodes.node_ranges(node));\nvar cs = (cljs.core.truth_(rngs)?(rngs[(32)]):clojure.core.rrb_vector.nodes.index_of_nil(arr));\nvar cseq = (function clojure$core$rrb_vector$rrbt$child_seq_$_cseq(c,r){\nvar arr__$1 = c.arr;\nvar rngs__$1 = ((clojure.core.rrb_vector.nodes.regular_QMARK_(c))?clojure.core.rrb_vector.nodes.regular_ranges((shift - (5)),r):clojure.core.rrb_vector.nodes.node_ranges(c));\nvar gcs = (cljs.core.truth_(rngs__$1)?(rngs__$1[(32)]):clojure.core.rrb_vector.nodes.index_of_nil(arr__$1));\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$3(cljs.core.list,cljs.core.take.cljs$core$IFn$_invoke$arity$2(gcs,arr__$1),cljs.core.take.cljs$core$IFn$_invoke$arity$2(gcs,cljs.core.map.cljs$core$IFn$_invoke$arity$3(cljs.core._,rngs__$1,cljs.core.cons((0),rngs__$1))));\n});\nreturn cljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic(cseq,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.take.cljs$core$IFn$_invoke$arity$2(cs,arr),cljs.core.take.cljs$core$IFn$_invoke$arity$2(cs,cljs.core.map.cljs$core$IFn$_invoke$arity$3(cljs.core._,rngs,cljs.core.cons((0),rngs)))], 0));\n});\nclojure.core.rrb_vector.rrbt.rebalance = (function clojure$core$rrb_vector$rrbt$rebalance(shift,n1,cnt1,n2,cnt2,transferred_leaves){\nif((n2 == null)){\nreturn [n1,null];\n} else {\nvar slc1 = clojure.core.rrb_vector.rrbt.slot_count(n1,shift);\nvar slc2 = clojure.core.rrb_vector.rrbt.slot_count(n2,shift);\nvar a = (slc1 + slc2);\nvar sbc1 = clojure.core.rrb_vector.rrbt.subtree_branch_count(n1,shift);\nvar sbc2 = clojure.core.rrb_vector.rrbt.subtree_branch_count(n2,shift);\nvar p = (sbc1 + sbc2);\nvar e = (a - (cljs.core.quot((p - (1)),(32)) + (1)));\nif((e <= (2))){\nreturn [n1,n2];\n} else {\nif(((sbc1 + sbc2) <= (1024))){\nvar new_arr = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar new_rngs = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar new_n1 = cljs.core.__GT_VectorNode(null,new_arr);\nvar i_11237 = (0);\nvar bs_11238 = cljs.core.partition_all.cljs$core$IFn$_invoke$arity$2((32),cljs.core.concat.cljs$core$IFn$_invoke$arity$2(clojure.core.rrb_vector.rrbt.child_seq(n1,shift,cnt1),clojure.core.rrb_vector.rrbt.child_seq(n2,shift,cnt2)));\nwhile(true){\nvar temp__5804__auto___11239 = cljs.core.seq(bs_11238);\nif(temp__5804__auto___11239){\nvar xs__6360__auto___11240 = temp__5804__auto___11239;\nvar block_11241 = cljs.core.first(xs__6360__auto___11240);\nvar a_11242__$1 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar r_11243 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\n(a_11242__$1[(32)] = r_11243);\n\n(r_11243[(32)] = cljs.core.count(block_11241));\n\nvar i_11244__$1 = (0);\nvar o_11245 = (0);\nvar gcs_11246 = cljs.core.seq(block_11241);\nwhile(true){\nvar temp__5804__auto___11247__$1 = cljs.core.seq(gcs_11246);\nif(temp__5804__auto___11247__$1){\nvar xs__6360__auto___11248__$1 = temp__5804__auto___11247__$1;\nvar vec__10784_11249 = cljs.core.first(xs__6360__auto___11248__$1);\nvar gc_11250 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__10784_11249,(0),null);\nvar gcr_11251 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__10784_11249,(1),null);\n(a_11242__$1[i_11244__$1] = gc_11250);\n\n(r_11243[i_11244__$1] = (o_11245 + gcr_11251));\n\nvar G__11252 = (i_11244__$1 + (1));\nvar G__11253 = (o_11245 + gcr_11251);\nvar G__11254 = cljs.core.next(gcs_11246);\ni_11244__$1 = G__11252;\no_11245 = G__11253;\ngcs_11246 = G__11254;\ncontinue;\n} else {\n}\nbreak;\n}\n\n(new_arr[i_11237] = cljs.core.__GT_VectorNode(null,a_11242__$1));\n\n(new_rngs[i_11237] = ((r_11243[((r_11243[(32)]) - (1))]) + (((i_11237 > (0)))?(new_rngs[(i_11237 - (1))]):(0))));\n\n(new_rngs[(32)] = (i_11237 + (1)));\n\nvar G__11257 = (i_11237 + (1));\nvar G__11258 = cljs.core.next(bs_11238);\ni_11237 = G__11257;\nbs_11238 = G__11258;\ncontinue;\n} else {\n}\nbreak;\n}\n\n(new_arr[(32)] = new_rngs);\n\n(transferred_leaves.val = cnt2);\n\nreturn [new_n1,null];\n} else {\nvar new_arr1 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar new_arr2 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar new_rngs1 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar new_rngs2 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar new_n1 = cljs.core.__GT_VectorNode(null,new_arr1);\nvar new_n2 = cljs.core.__GT_VectorNode(null,new_arr2);\nvar i_11260 = (0);\nvar bs_11261 = cljs.core.partition_all.cljs$core$IFn$_invoke$arity$2((32),cljs.core.concat.cljs$core$IFn$_invoke$arity$2(clojure.core.rrb_vector.rrbt.child_seq(n1,shift,cnt1),clojure.core.rrb_vector.rrbt.child_seq(n2,shift,cnt2)));\nwhile(true){\nvar temp__5804__auto___11262 = cljs.core.seq(bs_11261);\nif(temp__5804__auto___11262){\nvar xs__6360__auto___11263 = temp__5804__auto___11262;\nvar block_11264 = cljs.core.first(xs__6360__auto___11263);\nvar a_11265__$1 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar r_11266 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\n(a_11265__$1[(32)] = r_11266);\n\n(r_11266[(32)] = cljs.core.count(block_11264));\n\nvar i_11267__$1 = (0);\nvar o_11268 = (0);\nvar gcs_11269 = cljs.core.seq(block_11264);\nwhile(true){\nvar temp__5804__auto___11270__$1 = cljs.core.seq(gcs_11269);\nif(temp__5804__auto___11270__$1){\nvar xs__6360__auto___11271__$1 = temp__5804__auto___11270__$1;\nvar vec__10787_11272 = cljs.core.first(xs__6360__auto___11271__$1);\nvar gc_11273 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__10787_11272,(0),null);\nvar gcr_11274 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__10787_11272,(1),null);\n(a_11265__$1[i_11267__$1] = gc_11273);\n\n(r_11266[i_11267__$1] = (o_11268 + gcr_11274));\n\nvar G__11275 = (i_11267__$1 + (1));\nvar G__11276 = (o_11268 + gcr_11274);\nvar G__11277 = cljs.core.next(gcs_11269);\ni_11267__$1 = G__11275;\no_11268 = G__11276;\ngcs_11269 = G__11277;\ncontinue;\n} else {\n}\nbreak;\n}\n\nif((((i_11260 < (32))) && ((((i_11260 * (32)) + cljs.core.count(block_11264)) > sbc1)))){\nvar tbs_11278 = (((i_11260 * (32)) + cljs.core.count(block_11264)) - sbc1);\nvar li_11279 = ((r_11266[(32)]) - (1));\nvar d_11280 = (((tbs_11278 >= (32)))?(r_11266[li_11279]):((r_11266[li_11279]) - (r_11266[(li_11279 - tbs_11278)])));\n(transferred_leaves.val = (transferred_leaves.val + d_11280));\n} else {\n}\n\nvar new_arr_11281 = (((i_11260 < (32)))?new_arr1:new_arr2);\nvar new_rngs_11282 = (((i_11260 < (32)))?new_rngs1:new_rngs2);\nvar i_11283__$1 = cljs.core.mod(i_11260,(32));\n(new_arr_11281[i_11283__$1] = cljs.core.__GT_VectorNode(null,a_11265__$1));\n\n(new_rngs_11282[i_11283__$1] = ((r_11266[((r_11266[(32)]) - (1))]) + (((i_11283__$1 > (0)))?(new_rngs_11282[(i_11283__$1 - (1))]):(0))));\n\n(new_rngs_11282[(32)] = (i_11283__$1 + (1)));\n\nvar G__11285 = (i_11260 + (1));\nvar G__11286 = cljs.core.next(bs_11261);\ni_11260 = G__11285;\nbs_11261 = G__11286;\ncontinue;\n} else {\n}\nbreak;\n}\n\n(new_arr1[(32)] = new_rngs1);\n\n(new_arr2[(32)] = new_rngs2);\n\nreturn [new_n1,new_n2];\n\n}\n}\n}\n});\nclojure.core.rrb_vector.rrbt.zippath = (function clojure$core$rrb_vector$rrbt$zippath(shift,n1,cnt1,n2,cnt2,transferred_leaves){\nif((shift === (5))){\nreturn clojure.core.rrb_vector.rrbt.rebalance_leaves(n1,cnt1,n2,cnt2,transferred_leaves);\n} else {\nvar c1 = clojure.core.rrb_vector.nodes.last_child(n1);\nvar c2 = clojure.core.rrb_vector.nodes.first_child(n2);\nvar ccnt1 = ((clojure.core.rrb_vector.nodes.regular_QMARK_(n1))?(function (){var m = cljs.core.mod(cnt1,((1) << shift));\nif((m === (0))){\nreturn ((1) << shift);\n} else {\nreturn m;\n}\n})():(function (){var rngs = clojure.core.rrb_vector.nodes.node_ranges(n1);\nvar i = ((rngs[(32)]) - (1));\nif((i === (0))){\nreturn (rngs[(0)]);\n} else {\nreturn ((rngs[i]) - (rngs[(i - (1))]));\n}\n})());\nvar ccnt2 = ((clojure.core.rrb_vector.nodes.regular_QMARK_(n2))?(function (){var m = cljs.core.mod(cnt2,((1) << shift));\nif((m === (0))){\nreturn ((1) << shift);\n} else {\nreturn m;\n}\n})():(clojure.core.rrb_vector.nodes.node_ranges(n2)[(0)]));\nvar next_transferred_leaves = (new cljs.core.Box((0)));\nvar vec__10790 = (function (){var G__10793 = (shift - (5));\nvar G__10794 = c1;\nvar G__10795 = ccnt1;\nvar G__10796 = c2;\nvar G__10797 = ccnt2;\nvar G__10798 = next_transferred_leaves;\nreturn (clojure.core.rrb_vector.rrbt.zippath.cljs$core$IFn$_invoke$arity$6 ? clojure.core.rrb_vector.rrbt.zippath.cljs$core$IFn$_invoke$arity$6(G__10793,G__10794,G__10795,G__10796,G__10797,G__10798) : clojure.core.rrb_vector.rrbt.zippath.call(null, G__10793,G__10794,G__10795,G__10796,G__10797,G__10798));\n})();\nvar new_c1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__10790,(0),null);\nvar new_c2 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__10790,(1),null);\nvar d = next_transferred_leaves.val;\n(transferred_leaves.val = (transferred_leaves.val + d));\n\nreturn clojure.core.rrb_vector.rrbt.rebalance(shift,(((c1 === new_c1))?n1:clojure.core.rrb_vector.nodes.replace_rightmost_child(shift,n1,new_c1,d)),(cnt1 + d),(cljs.core.truth_(new_c2)?(((c2 === new_c2))?n2:clojure.core.rrb_vector.nodes.replace_leftmost_child(shift,n2,cnt2,new_c2,d)):clojure.core.rrb_vector.nodes.remove_leftmost_child(shift,n2)),(cnt2 - d),transferred_leaves);\n}\n});\nclojure.core.rrb_vector.rrbt.squash_nodes = (function clojure$core$rrb_vector$rrbt$squash_nodes(shift,n1,cnt1,n2,cnt2){\nvar arr1 = n1.arr;\nvar arr2 = n2.arr;\nvar li1 = clojure.core.rrb_vector.nodes.index_of_nil(arr1);\nvar li2 = clojure.core.rrb_vector.nodes.index_of_nil(arr2);\nvar slots = cljs.core.concat.cljs$core$IFn$_invoke$arity$2(cljs.core.take.cljs$core$IFn$_invoke$arity$2(li1,arr1),cljs.core.take.cljs$core$IFn$_invoke$arity$2(li2,arr2));\nif((cljs.core.count(slots) > (32))){\nreturn [n1,n2];\n} else {\nvar new_rngs = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar new_arr = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar rngs1 = cljs.core.take.cljs$core$IFn$_invoke$arity$2(li1,((clojure.core.rrb_vector.nodes.regular_QMARK_(n1))?clojure.core.rrb_vector.nodes.regular_ranges(shift,cnt1):clojure.core.rrb_vector.nodes.node_ranges(n1)));\nvar rngs2 = cljs.core.take.cljs$core$IFn$_invoke$arity$2(li2,((clojure.core.rrb_vector.nodes.regular_QMARK_(n2))?clojure.core.rrb_vector.nodes.regular_ranges(shift,cnt2):clojure.core.rrb_vector.nodes.node_ranges(n2)));\nvar rngs2__$1 = (function (){var r = cljs.core.last(rngs1);\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__10799_SHARP_){\nreturn (p1__10799_SHARP_ + r);\n}),rngs2);\n})();\nvar rngs = cljs.core.concat.cljs$core$IFn$_invoke$arity$2(rngs1,rngs2__$1);\n(new_arr[(32)] = new_rngs);\n\nvar i_11380 = (0);\nvar cs_11381 = cljs.core.seq(slots);\nwhile(true){\nif(cs_11381){\n(new_arr[i_11380] = cljs.core.first(cs_11381));\n\nvar G__11383 = (i_11380 + (1));\nvar G__11384 = cljs.core.next(cs_11381);\ni_11380 = G__11383;\ncs_11381 = G__11384;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar i_11388 = (0);\nvar rngs_11389__$1 = cljs.core.seq(rngs);\nwhile(true){\nif(rngs_11389__$1){\n(new_rngs[i_11388] = cljs.core.first(rngs_11389__$1));\n\nvar G__11390 = (i_11388 + (1));\nvar G__11391 = cljs.core.next(rngs_11389__$1);\ni_11388 = G__11390;\nrngs_11389__$1 = G__11391;\ncontinue;\n} else {\n(new_rngs[(32)] = i_11388);\n}\nbreak;\n}\n\nreturn [cljs.core.__GT_VectorNode(null,new_arr),null];\n}\n});\nclojure.core.rrb_vector.rrbt.peephole_optimization_config = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"debug-fn\",\"debug-fn\",777839250),null], null));\nclojure.core.rrb_vector.rrbt.peephole_optimization_count = cljs.core.atom.cljs$core$IFn$_invoke$arity$1((0));\nclojure.core.rrb_vector.rrbt.child_nodes = (function clojure$core$rrb_vector$rrbt$child_nodes(node){\nreturn cljs.core.take.cljs$core$IFn$_invoke$arity$2((32),cljs.core.take_while.cljs$core$IFn$_invoke$arity$2(cljs.core.complement(cljs.core.nil_QMARK_),node.arr));\n});\nclojure.core.rrb_vector.rrbt.bounded_grandchildren = (function clojure$core$rrb_vector$rrbt$bounded_grandchildren(children){\nreturn cljs.core.take.cljs$core$IFn$_invoke$arity$2((33),cljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic(clojure.core.rrb_vector.rrbt.child_nodes,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([children], 0)));\n});\nclojure.core.rrb_vector.rrbt.last_non_nil_idx = (function clojure$core$rrb_vector$rrbt$last_non_nil_idx(arr){\nvar i = (arr.length - (1));\nwhile(true){\nif((i < (0))){\nreturn i;\n} else {\nif(((arr[i]) == null)){\nvar G__11397 = (i - (1));\ni = G__11397;\ncontinue;\n} else {\nreturn i;\n}\n}\nbreak;\n}\n});\nclojure.core.rrb_vector.rrbt.count_vector_elements_beneath = (function clojure$core$rrb_vector$rrbt$count_vector_elements_beneath(node,shift){\nif(clojure.core.rrb_vector.nodes.regular_QMARK_(node)){\nvar node__$1 = node;\nvar shift__$1 = shift;\nvar acc = (0);\nwhile(true){\nif((shift__$1 === (0))){\nif((node__$1 == null)){\nreturn acc;\n} else {\nreturn (acc + (32));\n}\n} else {\nvar arr = node__$1.arr;\nvar max_child_idx = clojure.core.rrb_vector.rrbt.last_non_nil_idx(arr);\nvar num_elems_in_full_child = ((1) << shift__$1);\nif((max_child_idx < (0))){\nreturn acc;\n} else {\nvar G__11403 = (arr[max_child_idx]);\nvar G__11404 = (shift__$1 - (5));\nvar G__11405 = (acc + (max_child_idx * num_elems_in_full_child));\nnode__$1 = G__11403;\nshift__$1 = G__11404;\nacc = G__11405;\ncontinue;\n}\n}\nbreak;\n}\n} else {\nvar rngs = clojure.core.rrb_vector.nodes.node_ranges(node);\nreturn (rngs[((rngs[(32)]) - (1))]);\n}\n});\nclojure.core.rrb_vector.rrbt.peephole_optimize_root = (function clojure$core$rrb_vector$rrbt$peephole_optimize_root(v){\nvar config = cljs.core.deref(clojure.core.rrb_vector.rrbt.peephole_optimization_config);\nif((v.shift <= (10))){\nreturn v;\n} else {\nvar root = v.root;\nvar children = clojure.core.rrb_vector.rrbt.child_nodes(root);\nvar grandchildren = clojure.core.rrb_vector.rrbt.bounded_grandchildren(children);\nvar num_granchildren_bounded = cljs.core.count(grandchildren);\nvar many_grandchildren_QMARK_ = (num_granchildren_bounded > (32));\nif(many_grandchildren_QMARK_){\nreturn v;\n} else {\nvar new_arr = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar new_rngs = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar new_root = cljs.core.__GT_VectorNode(root.edit,new_arr);\nvar shift = v.shift;\nvar grandchild_shift = (shift - ((2) * (5)));\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(clojure.core.rrb_vector.rrbt.peephole_optimization_count,cljs.core.inc);\n\nvar idx_11434 = (0);\nvar remaining_gc_11435 = grandchildren;\nvar elem_sum_11436 = (0);\nwhile(true){\nvar temp__5802__auto___11438 = cljs.core.seq(remaining_gc_11435);\nif(temp__5802__auto___11438){\nvar remaining_gc_11442__$1 = temp__5802__auto___11438;\nvar grandchild_11443 = cljs.core.first(remaining_gc_11442__$1);\nvar num_elems_this_grandchild_11444 = clojure.core.rrb_vector.rrbt.count_vector_elements_beneath(grandchild_11443,grandchild_shift);\nvar next_elem_sum_11445 = (elem_sum_11436 + num_elems_this_grandchild_11444);\n(new_arr[idx_11434] = grandchild_11443);\n\n(new_rngs[idx_11434] = next_elem_sum_11445);\n\nvar G__11447 = (idx_11434 + (1));\nvar G__11448 = cljs.core.rest(remaining_gc_11442__$1);\nvar G__11449 = next_elem_sum_11445;\nidx_11434 = G__11447;\nremaining_gc_11435 = G__11448;\nelem_sum_11436 = G__11449;\ncontinue;\n} else {\n}\nbreak;\n}\n\n(new_rngs[(32)] = num_granchildren_bounded);\n\n(new_arr[(32)] = new_rngs);\n\nvar new_v = (new clojure.core.rrb_vector.rrbt.Vector(v.cnt,(shift - (5)),new_root,v.tail,v.meta,null));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"debug-fn\",\"debug-fn\",777839250).cljs$core$IFn$_invoke$arity$1(config))){\nvar fexpr__10809_11450 = new cljs.core.Keyword(null,\"debug-fn\",\"debug-fn\",777839250).cljs$core$IFn$_invoke$arity$1(config);\n(fexpr__10809_11450.cljs$core$IFn$_invoke$arity$2 ? fexpr__10809_11450.cljs$core$IFn$_invoke$arity$2(v,new_v) : fexpr__10809_11450.call(null, v,new_v));\n} else {\n}\n\nreturn new_v;\n}\n}\n});\nclojure.core.rrb_vector.rrbt.max_vector_elements = (2147483647);\nclojure.core.rrb_vector.rrbt.shift_too_large_QMARK_ = (function clojure$core$rrb_vector$rrbt$shift_too_large_QMARK_(v){\nreturn (v.shift > (30));\n});\nclojure.core.rrb_vector.rrbt.poor_branching_QMARK_ = (function clojure$core$rrb_vector$rrbt$poor_branching_QMARK_(v){\nvar tail_off = clojure.core.rrb_vector.rrbt._tail_offset(v);\nif((tail_off === (0))){\nreturn false;\n} else {\nvar shift_amount = (v.shift - (5));\nvar max_capacity_divided_by_1024 = ((1) << shift_amount);\nreturn (tail_off < max_capacity_divided_by_1024);\n}\n});\nclojure.core.rrb_vector.rrbt.fallback_config = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"debug-fn\",\"debug-fn\",777839250),null], null));\nclojure.core.rrb_vector.rrbt.fallback_to_slow_splice_count1 = cljs.core.atom.cljs$core$IFn$_invoke$arity$1((0));\nclojure.core.rrb_vector.rrbt.fallback_to_slow_splice_count2 = cljs.core.atom.cljs$core$IFn$_invoke$arity$1((0));\nclojure.core.rrb_vector.rrbt.fallback_to_slow_splice_if_needed = (function clojure$core$rrb_vector$rrbt$fallback_to_slow_splice_if_needed(v1,v2,splice_result){\nvar config = cljs.core.deref(clojure.core.rrb_vector.rrbt.fallback_config);\nif(((clojure.core.rrb_vector.rrbt.shift_too_large_QMARK_(splice_result)) || (clojure.core.rrb_vector.rrbt.poor_branching_QMARK_(splice_result)))){\n\nif(clojure.core.rrb_vector.rrbt.poor_branching_QMARK_(v1)){\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(clojure.core.rrb_vector.rrbt.fallback_to_slow_splice_count1,cljs.core.inc);\n\n\nvar new_splice_result = cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.empty(v1),v1),v2);\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"debug-fn\",\"debug-fn\",777839250).cljs$core$IFn$_invoke$arity$1(config))){\nvar fexpr__10829_11459 = new cljs.core.Keyword(null,\"debug-fn\",\"debug-fn\",777839250).cljs$core$IFn$_invoke$arity$1(config);\n(fexpr__10829_11459.cljs$core$IFn$_invoke$arity$2 ? fexpr__10829_11459.cljs$core$IFn$_invoke$arity$2(splice_result,new_splice_result) : fexpr__10829_11459.call(null, splice_result,new_splice_result));\n} else {\n}\n\nreturn new_splice_result;\n} else {\nvar new_splice_result = cljs.core.into.cljs$core$IFn$_invoke$arity$2(v1,v2);\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(clojure.core.rrb_vector.rrbt.fallback_to_slow_splice_count2,cljs.core.inc);\n\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"debug-fn\",\"debug-fn\",777839250).cljs$core$IFn$_invoke$arity$1(config))){\nvar fexpr__10830_11460 = new cljs.core.Keyword(null,\"debug-fn\",\"debug-fn\",777839250).cljs$core$IFn$_invoke$arity$1(config);\n(fexpr__10830_11460.cljs$core$IFn$_invoke$arity$2 ? fexpr__10830_11460.cljs$core$IFn$_invoke$arity$2(splice_result,new_splice_result) : fexpr__10830_11460.call(null, splice_result,new_splice_result));\n} else {\n}\n\nreturn new_splice_result;\n}\n} else {\nreturn splice_result;\n}\n});\nclojure.core.rrb_vector.rrbt.splice_rrbts_main = (function clojure$core$rrb_vector$rrbt$splice_rrbts_main(v1,v2){\nif((cljs.core.count(v1) === (0))){\nreturn v2;\n} else {\nif(((cljs.core.count(v1) + cljs.core.count(v2)) > clojure.core.rrb_vector.rrbt.max_vector_elements)){\nvar c1 = cljs.core.count(v1);\nvar c2 = cljs.core.count(v2);\nthrow (new Error([\"Attempted to concatenate two vectors whose total\",\" number of elements is \",cljs.core.str.cljs$core$IFn$_invoke$arity$1((c1 + c2)),\", which is\",\" larger than the maximum number of elements \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(clojure.core.rrb_vector.rrbt.max_vector_elements),\" supported in a vector \"].join('')));\n} else {\nif((cljs.core.count(v2) < (33))){\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(v1,v2);\n} else {\nvar s1 = v1.shift;\nvar s2 = v2.shift;\nvar r1 = v1.root;\nvar o_QMARK_ = clojure.core.rrb_vector.nodes.overflow_QMARK_(r1,s1,(cljs.core.count(v1) + ((32) - v1.tail.length)));\nvar r1__$1 = ((o_QMARK_)?(function (){var tail = v1.tail;\nvar tail_node = cljs.core.__GT_VectorNode(null,tail);\nvar reg_QMARK_ = ((clojure.core.rrb_vector.nodes.regular_QMARK_(r1)) && ((tail.length === (32))));\nvar arr = (new Array(((reg_QMARK_)?(32):(33))));\n(arr[(0)] = r1);\n\n(arr[(1)] = clojure.core.rrb_vector.nodes.new_path_STAR_(s1,tail_node));\n\nif((!(reg_QMARK_))){\nvar rngs_11469 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\n(rngs_11469[(32)] = (2));\n\n(rngs_11469[(0)] = (cljs.core.count(v1) - tail.length));\n\n(rngs_11469[(1)] = cljs.core.count(v1));\n\n(arr[(32)] = rngs_11469);\n} else {\n}\n\nreturn cljs.core.__GT_VectorNode(null,arr);\n})():clojure.core.rrb_vector.nodes.fold_tail(r1,s1,clojure.core.rrb_vector.rrbt._tail_offset(v1),v1.tail));\nvar s1__$1 = ((o_QMARK_)?(s1 + (5)):s1);\nvar r2 = v2.root;\nvar s = (function (){var x__5087__auto__ = s1__$1;\nvar y__5088__auto__ = s2;\nreturn ((x__5087__auto__ > y__5088__auto__) ? x__5087__auto__ : y__5088__auto__);\n})();\nvar r1__$2 = clojure.core.rrb_vector.rrbt.shift_from_to(r1__$1,s1__$1,s);\nvar r2__$1 = clojure.core.rrb_vector.rrbt.shift_from_to(r2,s2,s);\nvar transferred_leaves = (new cljs.core.Box((0)));\nvar vec__10837 = clojure.core.rrb_vector.rrbt.zippath(s,r1__$2,cljs.core.count(v1),r2__$1,(cljs.core.count(v2) - v2.tail.length),transferred_leaves);\nvar n1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__10837,(0),null);\nvar n2 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__10837,(1),null);\nvar d = transferred_leaves.val;\nvar ncnt1 = (cljs.core.count(v1) + d);\nvar ncnt2 = ((cljs.core.count(v2) - v2.tail.length) - d);\nvar vec__10840 = (((n2 === r2__$1))?clojure.core.rrb_vector.rrbt.squash_nodes(s,n1,ncnt1,n2,ncnt2):[n1,n2]);\nvar n1__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__10840,(0),null);\nvar n2__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__10840,(1),null);\nvar ncnt1__$1 = (cljs.core.truth_(n2__$1)?ncnt1:(ncnt1 + ncnt2));\nvar ncnt2__$1 = (cljs.core.truth_(n2__$1)?ncnt2:(0));\nif(cljs.core.truth_(n2__$1)){\nvar arr = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar new_root = cljs.core.__GT_VectorNode(null,arr);\n(arr[(0)] = n1__$1);\n\n(arr[(1)] = n2__$1);\n\n(arr[(32)] = (function (){var G__10855 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\n(G__10855[(0)] = ncnt1__$1);\n\n(G__10855[(1)] = (ncnt1__$1 + ncnt2__$1));\n\n(G__10855[(32)] = (2));\n\nreturn G__10855;\n})());\n\nreturn (new clojure.core.rrb_vector.rrbt.Vector((cljs.core.count(v1) + cljs.core.count(v2)),(s + (5)),new_root,v2.tail,null,null));\n} else {\nvar r = n1__$1;\nvar s__$1 = s;\nwhile(true){\nif((((s__$1 > (5))) && (((r.arr[(1)]) == null)))){\nvar G__11499 = (r.arr[(0)]);\nvar G__11500 = (s__$1 - (5));\nr = G__11499;\ns__$1 = G__11500;\ncontinue;\n} else {\nreturn (new clojure.core.rrb_vector.rrbt.Vector((cljs.core.count(v1) + cljs.core.count(v2)),s__$1,r,v2.tail,null,null));\n}\nbreak;\n}\n}\n\n}\n}\n}\n});\nclojure.core.rrb_vector.rrbt.splice_rrbts = (function clojure$core$rrb_vector$rrbt$splice_rrbts(v1,v2){\nvar r1 = clojure.core.rrb_vector.rrbt.splice_rrbts_main(v1,v2);\nvar r2 = clojure.core.rrb_vector.rrbt.peephole_optimize_root(r1);\nreturn clojure.core.rrb_vector.rrbt.fallback_to_slow_splice_if_needed(v1,v2,r2);\n});\n\n/**\n* @constructor\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ITransientCollection}\n * @implements {cljs.core.ITransientVector}\n * @implements {cljs.core.ITransientAssociative}\n * @implements {clojure.core.rrb_vector.rrbt.IVecImpl}\n*/\nclojure.core.rrb_vector.rrbt.Transient = (function (cnt,shift,root,tail,tidx){\nthis.cnt = cnt;\nthis.shift = shift;\nthis.root = root;\nthis.tail = tail;\nthis.tidx = tidx;\nthis.cljs$lang$protocol_mask$partition1$ = 88;\nthis.cljs$lang$protocol_mask$partition0$ = 2;\n});\n(clojure.core.rrb_vector.rrbt.Transient.prototype.cljs$core$ITransientCollection$_conj_BANG_$arity$2 = (function (this$,o){\nvar self__ = this;\nvar this$__$1 = this;\nif(self__.root.edit){\nif((self__.tidx < (32))){\n(self__.tail[self__.tidx] = o);\n\n(self__.cnt = (self__.cnt + (1)));\n\n(self__.tidx = (self__.tidx + (1)));\n\nreturn this$__$1;\n} else {\nvar tail_node = cljs.core.__GT_VectorNode(self__.root.edit,self__.tail);\nvar new_tail = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\n(new_tail[(0)] = o);\n\n(self__.tail = new_tail);\n\n(self__.tidx = (1));\n\nif(clojure.core.rrb_vector.nodes.overflow_QMARK_(self__.root,self__.shift,self__.cnt)){\nif(clojure.core.rrb_vector.nodes.regular_QMARK_(self__.root)){\nvar new_arr = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar G__10871_11506 = new_arr;\n(G__10871_11506[(0)] = self__.root);\n\n(G__10871_11506[(1)] = clojure.core.rrb_vector.trees.new_path(self__.tail,self__.root.edit,self__.shift,tail_node));\n\n\n(self__.root = cljs.core.__GT_VectorNode(self__.root.edit,new_arr));\n\n(self__.shift = (self__.shift + (5)));\n\n(self__.cnt = (self__.cnt + (1)));\n\nreturn this$__$1;\n} else {\nvar new_arr = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar new_rngs = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar new_root = cljs.core.__GT_VectorNode(self__.root.edit,new_arr);\nvar root_total_range = (clojure.core.rrb_vector.nodes.node_ranges(self__.root)[(31)]);\nvar G__10877_11509 = new_arr;\n(G__10877_11509[(0)] = self__.root);\n\n(G__10877_11509[(1)] = clojure.core.rrb_vector.trees.new_path(self__.tail,self__.root.edit,self__.shift,tail_node));\n\n(G__10877_11509[(32)] = new_rngs);\n\n\nvar G__10879_11512 = new_rngs;\n(G__10879_11512[(0)] = root_total_range);\n\n(G__10879_11512[(1)] = (root_total_range + (32)));\n\n(G__10879_11512[(32)] = (2));\n\n\n(self__.root = new_root);\n\n(self__.shift = (self__.shift + (5)));\n\n(self__.cnt = (self__.cnt + (1)));\n\nreturn this$__$1;\n}\n} else {\nvar new_root = clojure.core.rrb_vector.transients.push_tail_BANG_(self__.shift,self__.cnt,self__.root.edit,self__.root,tail_node);\n(self__.root = new_root);\n\n(self__.cnt = (self__.cnt + (1)));\n\nreturn this$__$1;\n}\n}\n} else {\nthrow (new Error(\"conj! after persistent!\"));\n}\n}));\n\n(clojure.core.rrb_vector.rrbt.Transient.prototype.cljs$core$ITransientCollection$_persistent_BANG_$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nif(self__.root.edit){\n(self__.root.edit = null);\n\nvar trimmed_tail = (new Array(self__.tidx));\ncljs.core.array_copy(self__.tail,(0),trimmed_tail,(0),self__.tidx);\n\nreturn (new clojure.core.rrb_vector.rrbt.Vector(self__.cnt,self__.shift,self__.root,trimmed_tail,null,null));\n} else {\nthrow (new Error(\"persistent! called twice\"));\n}\n}));\n\n(clojure.core.rrb_vector.rrbt.Transient.prototype.cljs$core$ITransientAssociative$_assoc_BANG_$arity$3 = (function (this$,key,val){\nvar self__ = this;\nvar this$__$1 = this;\nreturn this$__$1.cljs$core$ITransientVector$_assoc_n_BANG_$arity$3(null, key,val);\n}));\n\n(clojure.core.rrb_vector.rrbt.Transient.prototype.cljs$core$ITransientVector$_assoc_n_BANG_$arity$3 = (function (this$,i,val){\nvar self__ = this;\nvar this$__$1 = this;\nif(self__.root.edit){\nif(((((0) <= i)) && ((i < self__.cnt)))){\nvar tail_off = (self__.cnt - self__.tidx);\nif((tail_off <= i)){\n(self__.tail[(i - tail_off)] = val);\n} else {\n(self__.root = clojure.core.rrb_vector.transients.do_assoc_BANG_(self__.shift,self__.root.edit,self__.root,i,val));\n}\n\nreturn this$__$1;\n} else {\nif((i === self__.cnt)){\nreturn this$__$1.cljs$core$ITransientCollection$_conj_BANG_$arity$2(null, val);\n} else {\nreturn cljs.core.vector_index_out_of_bounds(i,self__.cnt);\n\n}\n}\n} else {\nthrow (new Error(\"assoc! after persistent!\"));\n}\n}));\n\n(clojure.core.rrb_vector.rrbt.Transient.prototype.cljs$core$ITransientVector$_pop_BANG_$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nif(self__.root.edit){\nif((self__.cnt === (0))){\nthrow (new Error(\"Can't pop empty vector\"));\n} else {\nif(((1) === self__.cnt)){\n(self__.cnt = (0));\n\n(self__.tidx = (0));\n\n(self__.tail[(0)] = null);\n\nreturn this$__$1;\n} else {\nif((self__.tidx > (1))){\n(self__.cnt = (self__.cnt - (1)));\n\n(self__.tidx = (self__.tidx - (1)));\n\n(self__.tail[self__.tidx] = null);\n\nreturn this$__$1;\n} else {\nvar new_tail_base = this$__$1.clojure$core$rrb_vector$rrbt$IVecImpl$_array_for$arity$2(null, (self__.cnt - (2)));\nvar new_tail = clojure.core.rrb_vector.transients.editable_tail(new_tail_base);\nvar new_tidx = new_tail_base.length;\nvar new_root = clojure.core.rrb_vector.transients.pop_tail_BANG_(self__.shift,self__.cnt,self__.root.edit,self__.root);\nif((new_root == null)){\n(self__.cnt = (self__.cnt - (1)));\n\n(self__.root = clojure.core.rrb_vector.transients.ensure_editable(self__.root.edit,clojure.core.rrb_vector.nodes.empty_node));\n\n(self__.tail = new_tail);\n\n(self__.tidx = new_tidx);\n\nreturn this$__$1;\n} else {\nif((((self__.shift > (5))) && (((new_root.arr[(1)]) == null)))){\n(self__.cnt = (self__.cnt - (1)));\n\n(self__.shift = (self__.shift - (5)));\n\n(self__.root = clojure.core.rrb_vector.transients.ensure_editable(self__.root.edit,(new_root.arr[(0)])));\n\n(self__.tail = new_tail);\n\n(self__.tidx = new_tidx);\n\nreturn this$__$1;\n} else {\n(self__.cnt = (self__.cnt - (1)));\n\n(self__.root = new_root);\n\n(self__.tail = new_tail);\n\n(self__.tidx = new_tidx);\n\nreturn this$__$1;\n\n}\n}\n\n}\n}\n}\n} else {\nthrow (new Error(\"count after persistent!\"));\n}\n}));\n\n(clojure.core.rrb_vector.rrbt.Transient.prototype.cljs$core$ICounted$_count$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nif(self__.root.edit){\nreturn self__.cnt;\n} else {\nthrow (new Error(\"count after persistent!\"));\n}\n}));\n\n(clojure.core.rrb_vector.rrbt.Transient.prototype.clojure$core$rrb_vector$rrbt$IVecImpl$ = cljs.core.PROTOCOL_SENTINEL);\n\n(clojure.core.rrb_vector.rrbt.Transient.prototype.clojure$core$rrb_vector$rrbt$IVecImpl$_tail_offset$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nreturn (self__.cnt - self__.tidx);\n}));\n\n(clojure.core.rrb_vector.rrbt.Transient.prototype.clojure$core$rrb_vector$rrbt$IVecImpl$_array_for$arity$2 = (function (this$,i){\nvar self__ = this;\nvar this$__$1 = this;\nif(((((0) <= i)) && ((i < self__.cnt)))){\nif((i >= this$__$1.clojure$core$rrb_vector$rrbt$IVecImpl$_tail_offset$arity$1(null, ))){\nreturn self__.tail;\n} else {\nvar i__$1 = i;\nvar node = self__.root;\nvar shift__$1 = self__.shift;\nwhile(true){\nif((shift__$1 === (0))){\nreturn node.arr;\n} else {\nif(clojure.core.rrb_vector.nodes.regular_QMARK_(node)){\nvar node__$1 = (node.arr[((i__$1 >> shift__$1) & (31))]);\nvar shift__$2 = (shift__$1 - (5));\nwhile(true){\nif((shift__$2 === (0))){\nreturn node__$1.arr;\n} else {\nvar G__11556 = (node__$1.arr[((i__$1 >> shift__$2) & (31))]);\nvar G__11557 = (shift__$2 - (5));\nnode__$1 = G__11556;\nshift__$2 = G__11557;\ncontinue;\n}\nbreak;\n}\n} else {\nvar rngs = clojure.core.rrb_vector.nodes.node_ranges(node);\nvar j = (function (){var j = ((i__$1 >> shift__$1) & (31));\nwhile(true){\nif((i__$1 < (rngs[j]))){\nreturn j;\n} else {\nvar G__11558 = (j + (1));\nj = G__11558;\ncontinue;\n}\nbreak;\n}\n})();\nvar i__$2 = (((j > (0)))?(i__$1 - (rngs[(j - (1))])):i__$1);\nvar G__11561 = i__$2;\nvar G__11562 = (node.arr[j]);\nvar G__11563 = (shift__$1 - (5));\ni__$1 = G__11561;\nnode = G__11562;\nshift__$1 = G__11563;\ncontinue;\n}\n}\nbreak;\n}\n}\n} else {\nreturn cljs.core.vector_index_out_of_bounds(i,self__.cnt);\n}\n}));\n\n(clojure.core.rrb_vector.rrbt.Transient.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(new cljs.core.Symbol(null,\"cnt\",\"cnt\",1924510325,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"shift\",\"shift\",-1657295705,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"root\",\"root\",1191874074,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"tail\",\"tail\",494507963,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"tidx\",\"tidx\",1939123455,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n}));\n\n(clojure.core.rrb_vector.rrbt.Transient.cljs$lang$type = true);\n\n(clojure.core.rrb_vector.rrbt.Transient.cljs$lang$ctorStr = \"clojure.core.rrb-vector.rrbt/Transient\");\n\n(clojure.core.rrb_vector.rrbt.Transient.cljs$lang$ctorPrWriter = (function (this__5287__auto__,writer__5288__auto__,opt__5289__auto__){\nreturn cljs.core._write(writer__5288__auto__,\"clojure.core.rrb-vector.rrbt/Transient\");\n}));\n\n/**\n * Positional factory function for clojure.core.rrb-vector.rrbt/Transient.\n */\nclojure.core.rrb_vector.rrbt.__GT_Transient = (function clojure$core$rrb_vector$rrbt$__GT_Transient(cnt,shift,root,tail,tidx){\nreturn (new clojure.core.rrb_vector.rrbt.Transient(cnt,shift,root,tail,tidx));\n});\n\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","clojure/core/rrb_vector/rrbt.cljs","~:line",9,"~:column",5,"~:end-line",9,"~:end-column",33],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$react","~$module$node_modules$react$index","~$react-dom","~$module$node_modules$react_dom$index"],"~:use-macros",["^ ","~$dbg","~$clojure.core.rrb-vector.macros"],"~:excludes",["~#set",["~$push-tail","~$new-path","~$do-assoc","~$pop-tail","~$array-for"]],"~:name","~$clojure.core.rrb-vector.rrbt","~:reader-aliases",["^ "],"~:op","~:ns","~:imports",null,"~:requires",["^ ","~$clojure.core.rrb-vector.protocols","^S","~$clojure.core.rrb-vector.nodes","^T","~$clojure.core.rrb-vector.trees","^U","~$clojure.core.rrb-vector.transients","^V","~$cljs.core","^W","~$goog","^X"],"~:seen",["^F",["~:require","~:require-macros"]],"~:uses",["^ ","~$editable-root","^V","~$push-tail!","^V","~$do-assoc!","^V","~$regular?","^T","~$ensure-editable","^V","^G","^U","~$remove-leftmost-child","^T","~$last-range","^T","~$node-ranges","^T","~$first-child","^T","~$new-path*","^T","^H","^U","~$editable-tail","^V","^I","^U","~$regular-ranges","^T","~$-slicev","^S","~$fold-tail","^T","~$PSliceableVector","^S","^J","^U","~$index-of-nil","^T","~$overflow?","^T","~$empty-node","^T","~$replace-leftmost-child","^T","~$-splicev","^S","~$last-child","^T","~$PSpliceableVector","^S","~$pop-tail!","^V","~$replace-rightmost-child","^T"],"^[",["^ ","^D","^D","^W","^W"],"~:form",["~#list",["~$ns","^M",["^1J",["~:refer-clojure","~:exclude",["^K","^G","^J","^H","^I"]]],["^1J",["^Z",["^S","~:refer",["^1?","^1=","^1F","^1D"]],["^T","^1N",["^14","^1B","^18","^1A","^17","^1<","^19","^1E","^16","^1C","^1H","^1>","^1:","^1@"]],["^U","^1N",["^G","^J","^H","^I"]],["^V","^1N",["^15","^11","^1;","^12","^1G","^13"]]]],["^1J",["^[",["^D","^1N",["^C"]]]]]],"~:flags",["^ ","^Z",["^F",[]],"^[",["^F",[]]],"~:js-deps",[],"~:deps",["^X","^W","^S","^T","^U","^V"]],"^P","^M","~:resource-id",["~:shadow.build.classpath/resource","clojure/core/rrb_vector/rrbt.cljs"],"~:compiled-at",1744168638447,"^N",["^ ","^S","^S","^T","^T","^U","^U","^V","^V","^W","^W","^X","^X","^D","^D"],"~:resource-name","clojure/core/rrb_vector/rrbt.cljs","~:warnings",[],"~:source",";   Copyright (c) Rich Hickey and contributors. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns clojure.core.rrb-vector.rrbt\n  (:refer-clojure :exclude [array-for push-tail pop-tail new-path do-assoc])\n  (:require [clojure.core.rrb-vector.protocols\n             :refer [PSliceableVector -slicev\n                     PSpliceableVector -splicev]]\n            [clojure.core.rrb-vector.nodes\n             :refer [regular? empty-node node-ranges overflow? last-range\n                     regular-ranges first-child last-child remove-leftmost-child\n                     replace-leftmost-child replace-rightmost-child\n                     fold-tail new-path* index-of-nil]]\n            [clojure.core.rrb-vector.trees\n             :refer [push-tail pop-tail new-path do-assoc]]\n            [clojure.core.rrb-vector.transients\n             :refer [ensure-editable editable-root editable-tail push-tail!\n                     pop-tail! do-assoc!]])\n  (:require-macros [clojure.core.rrb-vector.macros :refer [dbg]]))\n\n(def ^:const rrbt-concat-threshold 33)\n(def ^:const max-extra-search-steps 2)\n\n(defprotocol IVecImpl\n  (-tail-offset [v])\n  (-array-for [v i]))\n\n(defprotocol AsRRBT\n  (-as-rrbt [v]))\n\n;;; chunked seqs: can't reuse cljs.core's without tweaks, since rrb\n;;; vectors have a different array-for\n\n(declare rrb-chunked-seq)\n\n(deftype RRBChunkedSeq [vec node i off meta ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  IPrintWithWriter\n  (-pr-writer [this writer opts]\n    (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts this))\n\n  IWithMeta\n  (-with-meta [coll m]\n    (rrb-chunked-seq vec node i off m))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ASeq\n  ISeq\n  (-first [coll]\n    (aget node off))\n\n  (-rest [coll]\n    (if (< (inc off) (alength node))\n      (let [s (rrb-chunked-seq vec node i (inc off))]\n        (if (nil? s)\n          ()\n          s))\n      (-chunked-rest coll)))\n\n  INext\n  (-next [coll]\n    (if (< (inc off) (alength node))\n      (let [s (rrb-chunked-seq vec node i (inc off))]\n        (if (nil? s)\n          nil\n          s))\n      (-chunked-next coll)))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll]\n    (with-meta cljs.core.List.EMPTY meta))\n\n  IChunkedSeq\n  (-chunked-first [coll]\n    (array-chunk node off))\n\n  (-chunked-rest [coll]\n    (let [l (alength node)\n          s (when (< (+ i l) (-count vec))\n              (rrb-chunked-seq vec (+ i l) 0))]\n      (if (nil? s)\n        ()\n        s)))\n\n  IChunkedNext\n  (-chunked-next [coll]\n    (let [l (alength node)\n          s (when (< (+ i l) (-count vec))\n              (rrb-chunked-seq vec (+ i l) 0))]\n      (if (nil? s)\n        nil\n        s)))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IReduce\n  (-reduce [coll f]\n    (ci-reduce (cljs.core/subvec vec (+ i off) (count vec)) f))\n\n  (-reduce [coll f start]\n    (ci-reduce (cljs.core/subvec vec (+ i off) (count vec)) f start)))\n\n(defn rrb-chunked-seq\n  ([vec i off]\n     (RRBChunkedSeq. vec (-array-for vec i) i off nil nil))\n  ([vec node i off]\n     (RRBChunkedSeq. vec node i off nil nil))\n  ([vec node i off meta]\n     (RRBChunkedSeq. vec node i off meta nil)))\n\n(defn slice-right [node shift end]\n  (if (zero? shift)\n    ;; potentially return a short node, although it would be better to\n    ;; make sure a regular leaf is always left at the right, with any\n    ;; items over the final 32 moved into tail (and then potentially\n    ;; back into the tree should the tail become too long...)\n    (let [arr     (.-arr node)\n          new-arr (make-array end)]\n      (array-copy arr 0 new-arr 0 end)\n      (->VectorNode nil new-arr))\n    (let [reg? (regular? node)\n          rngs (if-not reg? (node-ranges node))\n          i    (bit-and (bit-shift-right (dec end) shift) 0x1f)\n          i    (if reg?\n                 i\n                 (loop [j i]\n                   (if (<= end (aget rngs j))\n                     j\n                     (recur (inc j)))))\n          child-end (if reg?\n                      (let [ce (mod end (bit-shift-left 1 shift))]\n                        (if (zero? ce) (bit-shift-left 1 shift) ce))\n                      (if (pos? i)\n                        (- end (aget rngs (dec i)))\n                        end))\n          arr       (.-arr node)\n          new-child (slice-right (aget arr i) (- shift 5) child-end)\n          regular-child? (if (== shift 5)\n                           (== 32 (alength (.-arr new-child)))\n                           (regular? new-child))\n          new-arr   (make-array (if (and reg? regular-child?) 32 33))\n          new-child-rng  (if regular-child?\n                           (let [m (mod child-end (bit-shift-left 1 shift))]\n                             (if (zero? m) (bit-shift-left 1 shift) m))\n                           (if (== shift 5)\n                             (alength (.-arr new-child))\n                             (last-range new-child)))]\n      (array-copy arr 0 new-arr 0 i)\n      (aset new-arr i new-child)\n      (if-not (and reg? regular-child?)\n        (let [new-rngs (make-array 33)\n              step     (bit-shift-left 1 shift)]\n          (if reg?\n            (dotimes [j i]\n              (aset new-rngs j (* (inc j) step)))\n            (dotimes [j i]\n              (aset new-rngs j (aget rngs j))))\n          (aset new-rngs i (+ (if (pos? i) (aget new-rngs (dec i)) 0)\n                              new-child-rng))\n          (aset new-rngs 32 (inc i))\n          (aset new-arr 32 new-rngs)))\n      (->VectorNode nil new-arr))))\n\n(defn slice-left [node shift start end]\n  (if (zero? shift)\n    ;; potentially return a short node\n    (let [arr     (.-arr node)\n          new-len (- (alength arr) start)\n          new-arr (make-array new-len)]\n      (array-copy arr start new-arr 0 new-len)\n      (->VectorNode nil new-arr))\n    (let [reg? (regular? node)\n          arr  (.-arr node)\n          rngs (if-not reg? (node-ranges node))\n          i    (bit-and (bit-shift-right start shift) 0x1f)\n          i    (if reg?\n                 i\n                 (loop [j i]\n                   (if (< start (aget rngs j))\n                     j\n                     (recur (inc j)))))\n          len  (if reg?\n                 (loop [i i]\n                   (if (or (== i 32) (nil? (aget arr i)))\n                     i\n                     (recur (inc i))))\n                 (aget rngs 32))\n          child-start (if (pos? i)\n                        (- start\n                           (if reg?\n                             (* i (bit-shift-left 1 shift))\n                             (aget rngs (dec i))))\n                        start)\n          child-end   (if reg?\n                        (min (bit-shift-left 1 shift)\n                             (if (pos? i)\n                               (- end (* i (bit-shift-left 1 shift)))\n                               end))\n                        (let [capped-end (min (aget rngs i) end)]\n                          (if (pos? i)\n                            (- capped-end (aget rngs (dec i)))\n                            capped-end)))\n          new-child   (slice-left (aget arr i)\n                                  (- shift 5)\n                                  child-start\n                                  child-end)\n          new-len     (- len i)\n          new-len     (if (nil? new-child) (dec new-len) new-len)]\n      (cond\n        (zero? new-len)\n        nil\n\n        reg?\n        (let [new-arr (make-array 33)\n              rngs    (make-array 33)\n              rng0    (if (or (nil? new-child)\n                              (== shift 5)\n                              (regular? new-child))\n                        (- (bit-shift-left 1 shift)\n                           (bit-and (bit-shift-right start (- shift 5)) 0x1f))\n                        (last-range new-child))\n              step    (bit-shift-left 1 shift)]\n          (loop [j 0\n                 r rng0]\n            (when (< j new-len)\n              (aset rngs j r)\n              (recur (inc j) (+ r step))))\n          (when (> new-len 1)\n            (aset rngs (dec new-len) (- end start)))\n          (aset rngs 32 new-len)\n          (array-copy arr (if (nil? new-child) (inc i) i)\n                      new-arr 0\n                      new-len)\n          (if-not (nil? new-child)\n            (aset new-arr 0 new-child))\n          (aset new-arr 32 rngs)\n          (->VectorNode (.-edit node) new-arr))\n\n        :else\n        (let [new-arr  (make-array 33)\n              new-rngs (make-array 33)]\n          (loop [j 0 i i]\n            (when (< j new-len)\n              (aset new-rngs j (- (aget rngs i) start))\n              (recur (inc j) (inc i))))\n          (aset new-rngs 32 new-len)\n          (array-copy arr (if (nil? new-child) (inc i) i)\n                      new-arr 0\n                      new-len)\n          (if-not (nil? new-child)\n            (aset new-arr 0 new-child))\n          (aset new-arr 32 new-rngs)\n          (->VectorNode (.-edit node) new-arr))))))\n\n(declare splice-rrbts ->Transient)\n\n(deftype Vector [cnt shift root tail meta ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str* this))\n\n  IPrintWithWriter\n  (-pr-writer [this writer opts]\n    (pr-sequential-writer writer pr-writer \"[\" \" \" \"]\" opts this))\n\n  IWithMeta\n  (-with-meta [this meta]\n    (Vector. cnt shift root tail meta __hash))\n\n  IMeta\n  (-meta [this]\n    meta)\n\n  ISequential\n  IEquiv\n  (-equiv [this that]\n    (equiv-sequential this that))\n\n  IHash\n  (-hash [this]\n    (caching-hash this hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [this]\n    (cond\n      (zero? cnt) nil\n      (zero? (-tail-offset this)) (array-seq tail)\n      :else (rrb-chunked-seq this 0 0)))\n\n  ICounted\n  (-count [_]\n    cnt)\n\n  IIndexed\n  (-nth [this i]\n    (if (and (<= 0 i) (< i cnt))\n      (let [tail-off (- cnt (alength tail))]\n        (if (<= tail-off i)\n          (aget tail (- i tail-off))\n          (loop [i i node root shift shift]\n            (if (zero? shift)\n              (let [arr (.-arr node)]\n                (aget arr (bit-and (bit-shift-right i shift) 0x1f)))\n              (if (regular? node)\n                (let [arr (.-arr node)\n                      idx (bit-and (bit-shift-right i shift) 0x1f)]\n                  (loop [i     i\n                         node  (aget arr idx)\n                         shift (- shift 5)]\n                    (let [arr (.-arr node)\n                          idx (bit-and (bit-shift-right i shift) 0x1f)]\n                      (if (zero? shift)\n                        (aget arr idx)\n                        (recur i (aget arr idx) (- shift 5))))))\n                (let [arr  (.-arr node)\n                      rngs (node-ranges node)\n                      idx  (loop [j (bit-and (bit-shift-right i shift) 0x1f)]\n                             (if (< i (aget rngs j))\n                               j\n                               (recur (inc j))))\n                      i    (if (zero? idx)\n                             i\n                             (- i (aget rngs (dec idx))))]\n                  (recur i (aget arr idx) (- shift 5))))))))\n      (vector-index-out-of-bounds i cnt)))\n\n  (-nth [this i not-found]\n    (if (and (>= i 0) (< i cnt))\n      (-nth this i)\n      not-found))\n\n  IMapEntry\n  (-key [this]\n    (-nth this 0))\n\n  (-val [this]\n    (-nth this 1))\n\n  ICollection\n  (-conj [this val]\n    (if (< (alength tail) 32)\n      (let [tail-len (alength tail)\n            new-tail (make-array (inc tail-len))]\n        (array-copy tail 0 new-tail 0 tail-len)\n        (aset new-tail tail-len val)\n        (Vector. (inc cnt) shift root new-tail meta nil))\n      (let [tail-node (->VectorNode (.-edit root) tail)\n            new-tail  (let [new-arr (make-array 1)]\n                        (aset new-arr 0 val)\n                        new-arr)]\n        (if (overflow? root shift cnt)\n          (if (regular? root)\n            (let [new-arr  (make-array 32)\n                  new-root (->VectorNode (.-edit root) new-arr)]\n              (doto new-arr\n                (aset 0 root)\n                (aset 1 (new-path tail (.-edit root) shift tail-node)))\n              (Vector. (inc cnt) (+ shift 5) new-root new-tail meta nil))\n            (let [new-arr  (make-array 33)\n                  new-rngs (make-array 33)\n                  new-root (->VectorNode (.-edit root) new-arr)\n                  root-total-range (aget (node-ranges root) 31)]\n              (doto new-arr\n                (aset 0  root)\n                (aset 1  (new-path tail (.-edit root) shift tail-node))\n                (aset 32 new-rngs))\n              (doto new-rngs\n                (aset 0  root-total-range)\n                (aset 1  (+ root-total-range 32))\n                (aset 32 2))\n              (Vector. (inc cnt) (+ shift 5) new-root new-tail meta nil)))\n          (Vector. (inc cnt) shift\n                   (push-tail shift cnt (.-edit root) root tail-node)\n                   new-tail\n                   meta\n                   nil)))))\n\n  IEmptyableCollection\n  (-empty [_]\n    (with-meta cljs.core.PersistentVector.EMPTY meta))\n\n  IStack\n  (-peek [this]\n    (when (pos? cnt)\n      (-nth this (dec cnt))))\n\n  (-pop [this]\n    (cond\n      (zero? cnt)\n      (throw (js/Error. \"Can't pop empty vector\"))\n\n      (== 1 cnt)\n      (-with-meta cljs.core.PersistentVector.EMPTY meta)\n\n      (> (alength tail) 1)\n      (let [new-tail (make-array (dec (alength tail)))]\n        (array-copy tail 0 new-tail 0 (alength new-tail))\n        (Vector. (dec cnt) shift root new-tail meta nil))\n\n      :else\n      (let [new-tail (-array-for this (- cnt 2))\n            root-cnt (-tail-offset this)\n            new-root (pop-tail shift root-cnt (.-edit root) root)]\n        (cond\n          (nil? new-root)\n          (Vector. (dec cnt) shift empty-node new-tail meta nil)\n\n          (and (> shift 5)\n               (nil? (aget (.-arr new-root) 1)))\n          (Vector. (dec cnt)\n                   (- shift 5)\n                   (aget (.-arr new-root) 0)\n                   new-tail\n                   meta\n                   nil)\n\n          :else\n          (Vector. (dec cnt) shift new-root new-tail meta nil)))))\n\n  IVector\n  (-assoc-n [this i val]\n    (cond\n      (and (<= 0 i) (< i cnt))\n      (let [tail-off (-tail-offset this)]\n        (if (>= i tail-off)\n          (let [new-tail (make-array (alength tail))\n                idx (- i tail-off)]\n            (array-copy tail 0 new-tail 0 (alength tail))\n            (aset new-tail idx val)\n            (Vector. cnt shift root new-tail meta nil))\n          (Vector. cnt shift (do-assoc shift root i val) tail meta nil)))\n\n      (== i cnt) (-conj this val)\n      :else (vector-index-out-of-bounds i cnt)))\n\n  IReversible\n  (-rseq [this]\n    (if (pos? cnt)\n      (RSeq. this (dec cnt) nil)\n      nil))\n\n  IAssociative\n  (-assoc [this k v]\n    (-assoc-n this k v))\n\n  ILookup\n  (-lookup [this k]\n    (-nth this k nil))\n\n  (-lookup [this k not-found]\n    (-nth this k not-found))\n\n  IFn\n  (-invoke [this k]\n    (-nth this k))\n\n  (-invoke [this k not-found]\n    (-nth this k not-found))\n\n  IReduce\n  (-reduce [this f]\n    (ci-reduce this f))\n\n  (-reduce [this f start]\n    (ci-reduce this f start))\n\n  IKVReduce\n  (-kv-reduce [this f init]\n    (if (zero? cnt)\n      init\n      (loop [i    0\n             j    0\n             init init\n             arr  (-array-for this i)\n             lim  (dec (alength arr))\n             step (inc lim)]\n        (let [init (f init (+ i j) (aget arr j))]\n          (if (reduced? init)\n            @init\n            (if (< j lim)\n              (recur i (inc j) init arr lim step)\n              (let [i (+ i step)]\n                (if (< i cnt)\n                  (let [arr (-array-for this i)\n                        len (alength arr)\n                        lim (dec len)]\n                    (recur i 0 init arr lim len))\n                  init))))))))\n\n  IComparable\n  (-compare [this that]\n    (compare-indexed this that))\n\n  IEditableCollection\n  (-as-transient [this]\n    (->Transient cnt\n                 shift\n                 (editable-root root)\n                 (editable-tail tail)\n                 (alength tail)))\n\n  PSliceableVector\n  (-slicev [this start end]\n    (let [new-cnt (- end start)]\n      (cond\n        (or (neg? start) (> end cnt))\n        (throw (js/Error. \"vector index out of bounds\"))\n\n        (== start end)\n        ;; NB. preserves metadata\n        (empty this)\n\n        (> start end)\n        (throw (js/Error. \"start index greater than end index\"))\n\n        :else\n        (let [tail-off (-tail-offset this)]\n          (if (>= start tail-off)\n            (let [new-tail (make-array new-cnt)]\n              (array-copy tail (- start tail-off)\n                          new-tail 0\n                          new-cnt)\n              (Vector. new-cnt 5 empty-node new-tail meta nil))\n            (let [tail-cut? (> end tail-off)\n                  new-root  (if tail-cut?\n                              root\n                              (slice-right root shift end))\n                  new-root  (if (zero? start)\n                              new-root\n                              (slice-left new-root shift start\n                                          (min end tail-off)))\n                  new-tail  (if tail-cut?\n                              (let [new-len  (- end tail-off)\n                                    new-tail (make-array new-len)]\n                                (array-copy tail 0 new-tail 0 new-len)\n                                new-tail)\n                              (-array-for (Vector. new-cnt shift new-root\n                                                   (array) meta nil)\n                                          (dec new-cnt)))\n                  new-root  (if tail-cut?\n                              new-root\n                              (pop-tail shift new-cnt (.-edit new-root)\n                                        new-root))]\n              (if (nil? new-root)\n                (Vector. new-cnt 5 empty-node new-tail meta nil)\n                (loop [r new-root\n                       s shift]\n                  (if (and (> s 5)\n                           (nil? (aget (.-arr r) 1)))\n                    (recur (aget (.-arr r) 0) (- s 5))\n                    (Vector. new-cnt s r new-tail meta nil))))))))))\n\n  PSpliceableVector\n  (-splicev [this that]\n    (splice-rrbts this (-as-rrbt that)))\n\n  IVecImpl\n  (-tail-offset [this]\n    (- cnt (alength tail)))\n\n  (-array-for [this i]\n    (if (and (<= 0 i) (< i cnt))\n      (if (>= i (-tail-offset this))\n        tail\n        (loop [i i node root shift shift]\n          (if (zero? shift)\n            (.-arr node)\n            (if (regular? node)\n              (loop [node  (aget (.-arr node)\n                                 (bit-and (bit-shift-right i shift) 0x1f))\n                     shift (- shift 5)]\n                (if (zero? shift)\n                  (.-arr node)\n                  (recur (aget (.-arr node)\n                               (bit-and (bit-shift-right i shift) 0x1f))\n                         (- shift 5))))\n              (let [rngs (node-ranges node)\n                    j    (loop [j (bit-and (bit-shift-right i shift) 0x1f)]\n                           (if (< i (aget rngs j))\n                             j\n                             (recur (inc j))))\n                    i    (if (pos? j)\n                           (- i (aget rngs (dec j)))\n                           i)]\n                (recur i\n                       (aget (.-arr node) j)\n                       (- shift 5)))))))\n      (vector-index-out-of-bounds i cnt)))\n\n  AsRRBT\n  (-as-rrbt [this]\n    this))\n\n(extend-protocol AsRRBT\n  cljs.core.PersistentVector\n  (-as-rrbt [this]\n    (Vector. (count this) (.-shift this) (.-root this) (.-tail this)\n             (meta this) nil))\n\n  Subvec\n  (-as-rrbt [this]\n    (let [v     (.-v this)\n          start (.-start this)\n          end   (.-end this)]\n      (-slicev (-as-rrbt v) start end))))\n\n(defn shift-from-to [node from to]\n  (cond\n    (== from to)\n    node\n\n    (regular? node)\n    (recur (->VectorNode (.-edit node) (doto (make-array 32) (aset 0 node)))\n           (+ 5 from)\n           to)\n\n    :else\n    (recur (->VectorNode (.-edit node)\n                         (doto (make-array 33)\n                           (aset 0 node)\n                           (aset 32\n                                 (doto (make-array 33)\n                                   (aset 0  (last-range node))\n                                   (aset 32 1)))))\n           (+ 5 from)\n           to)))\n\n(defn slot-count [node shift]\n  (let [arr (.-arr node)]\n    (if (zero? shift)\n      (alength arr)\n      (if (regular? node)\n        (index-of-nil arr)\n        (let [rngs (node-ranges node)]\n          (aget rngs 32))))))\n\n(defn subtree-branch-count [node shift]\n  ;; NB. positive shifts only\n  (let [arr (.-arr node)\n        cs  (- shift 5)]\n    (if (regular? node)\n      (loop [i 0 sbc 0]\n        (if (== i 32)\n          sbc\n          (if-let [child (aget arr i)]\n            (recur (inc i) (+ sbc (slot-count child cs)))\n            sbc)))\n      (let [lim (aget (node-ranges node) 32)]\n        (loop [i 0 sbc 0]\n          (if (== i lim)\n            sbc\n            (let [child (aget arr i)]\n              (recur (inc i) (+ sbc (slot-count child cs))))))))))\n\n(defn leaf-seq [arr]\n  (mapcat #(.-arr %) (take (index-of-nil arr) arr)))\n\n(defn rebalance-leaves\n  [n1 cnt1 n2 cnt2 transferred-leaves]\n  (let [slc1 (slot-count n1 5)\n        slc2 (slot-count n2 5)\n        a    (+ slc1 slc2)\n        sbc1 (subtree-branch-count n1 5)\n        sbc2 (subtree-branch-count n2 5)\n        p    (+ sbc1 sbc2)\n        e    (- a (inc (quot (dec p) 32)))]\n    (cond\n      (<= e max-extra-search-steps)\n      (array n1 n2)\n\n      (<= (+ sbc1 sbc2) 1024)\n      (let [reg?    (zero? (mod p 32))\n            new-arr (make-array (if reg? 32 33))\n            new-n1  (->VectorNode nil new-arr)]\n        (loop [i  0\n               bs (partition-all 32\n                                 (concat (leaf-seq (.-arr n1))\n                                         (leaf-seq (.-arr n2))))]\n          (when-first [block bs]\n            (let [a (make-array (count block))]\n              (loop [i 0 xs (seq block)]\n                (when xs\n                  (aset a i (first xs))\n                  (recur (inc i) (next xs))))\n              (aset new-arr i (->VectorNode nil a))\n              (recur (inc i) (next bs)))))\n        (if-not reg?\n          (aset new-arr 32 (regular-ranges 5 p)))\n        (set! (.-val transferred-leaves) sbc2)\n        (array new-n1 nil))\n\n      :else\n      (let [reg?     (zero? (mod p 32))\n            new-arr1 (make-array 32)\n            new-arr2 (make-array (if reg? 32 33))\n            new-n1   (->VectorNode nil new-arr1)\n            new-n2   (->VectorNode nil new-arr2)]\n        (loop [i  0\n               bs (partition-all 32\n                                 (concat (leaf-seq (.-arr n1))\n                                         (leaf-seq (.-arr n2))))]\n          (when-first [block bs]\n            (let [a (make-array (count block))]\n              (loop [i 0 xs (seq block)]\n                (when xs\n                  (aset a i (first xs))\n                  (recur (inc i) (next xs))))\n              (if (< i 32)\n                (aset new-arr1 i (->VectorNode nil a))\n                (aset new-arr2 (- i 32) (->VectorNode nil a)))\n              (recur (inc i) (next bs)))))\n        (if-not reg?\n          (aset new-arr2 32 (regular-ranges 5 (- p 1024))))\n        (set! (.-val transferred-leaves) (- 1024 sbc1))\n        (array new-n1 new-n2)))))\n\n(defn child-seq [node shift cnt]\n  (let [arr  (.-arr node)\n        rngs (if (regular? node)\n               (regular-ranges shift cnt)\n               (node-ranges node))\n        cs   (if rngs (aget rngs 32) (index-of-nil arr))\n        cseq (fn cseq [c r]\n               (let [arr  (.-arr c)\n                     rngs (if (regular? c)\n                            (regular-ranges (- shift 5) r)\n                            (node-ranges c))\n                     gcs  (if rngs (aget rngs 32) (index-of-nil arr))]\n                 (map list\n                      (take gcs arr)\n                      (take gcs (map - rngs (cons 0 rngs))))))]\n    (mapcat cseq (take cs arr) (take cs (map - rngs (cons 0 rngs))))))\n\n(defn rebalance\n  [shift n1 cnt1 n2 cnt2 transferred-leaves]\n  (if (nil? n2)\n    (array n1 nil)\n    (let [slc1 (slot-count n1 shift)\n          slc2 (slot-count n2 shift)\n          a    (+ slc1 slc2)\n          sbc1 (subtree-branch-count n1 shift)\n          sbc2 (subtree-branch-count n2 shift)\n          p    (+ sbc1 sbc2)\n          e    (- a (inc (quot (dec p) 32)))]\n      (cond\n        (<= e max-extra-search-steps)\n        (array n1 n2)\n\n        (<= (+ sbc1 sbc2) 1024)\n        (let [new-arr  (make-array 33)\n              new-rngs (make-array 33)\n              new-n1   (->VectorNode nil new-arr)]\n          (loop [i  0\n                 bs (partition-all 32\n                                   (concat (child-seq n1 shift cnt1)\n                                           (child-seq n2 shift cnt2)))]\n            (when-first [block bs]\n              (let [a (make-array 33)\n                    r (make-array 33)]\n                (aset a 32 r)\n                (aset r 32 (count block))\n                (loop [i 0 o 0 gcs (seq block)]\n                  (when-first [[gc gcr] gcs]\n                    (aset a i gc)\n                    (aset r i (+ o gcr))\n                    (recur (inc i) (+ o gcr) (next gcs))))\n                (aset new-arr i (->VectorNode nil a))\n                (aset new-rngs i\n                      (+ (aget r (dec (aget r 32)))\n                         (if (pos? i) (aget new-rngs (dec i)) 0)))\n                (aset new-rngs 32 (inc i))\n                (recur (inc i) (next bs)))))\n          (aset new-arr 32 new-rngs)\n          (set! (.-val transferred-leaves) cnt2)\n          (array new-n1 nil))\n\n        :else\n        (let [new-arr1  (make-array 33)\n              new-arr2  (make-array 33)\n              new-rngs1 (make-array 33)\n              new-rngs2 (make-array 33)\n              new-n1    (->VectorNode nil new-arr1)\n              new-n2    (->VectorNode nil new-arr2)]\n          (loop [i  0\n                 bs (partition-all 32\n                                   (concat (child-seq n1 shift cnt1)\n                                           (child-seq n2 shift cnt2)))]\n            (when-first [block bs]\n              (let [a (make-array 33)\n                    r (make-array 33)]\n                (aset a 32 r)\n                (aset r 32 (count block))\n                (loop [i 0 o 0 gcs (seq block)]\n                  (when-first [[gc gcr] gcs]\n                    (aset a i gc)\n                    (aset r i (+ o gcr))\n                    (recur (inc i) (+ o gcr) (next gcs))))\n                (if (and (< i 32) (> (+ (* i 32) (count block)) sbc1))\n                  (let [tbs (- (+ (* i 32) (count block)) sbc1)\n                        li  (dec (aget r 32))\n                        d   (if (>= tbs 32)\n                              (aget r li)\n                              (- (aget r li) (aget r (- li tbs))))]\n                    (set! (.-val transferred-leaves)\n                          (+ (.-val transferred-leaves) d))))\n                (let [new-arr  (if (< i 32) new-arr1 new-arr2)\n                      new-rngs (if (< i 32) new-rngs1 new-rngs2)\n                      i        (mod i 32)]\n                  (aset new-arr i (->VectorNode nil a))\n                  (aset new-rngs i\n                        (+ (aget r (dec (aget r 32)))\n                           (if (pos? i) (aget new-rngs (dec i)) 0)))\n                  (aset new-rngs 32 (inc i)))\n                (recur (inc i) (next bs)))))\n          (aset new-arr1 32 new-rngs1)\n          (aset new-arr2 32 new-rngs2)\n          (array new-n1 new-n2))))))\n\n(defn zippath\n  [shift n1 cnt1 n2 cnt2 transferred-leaves]\n  (if (== shift 5)\n    (rebalance-leaves n1 cnt1 n2 cnt2 transferred-leaves)\n    (let [c1 (last-child n1)\n          c2 (first-child n2)\n          ccnt1 (if (regular? n1)\n                  (let [m (mod cnt1 (bit-shift-left 1 shift))]\n                    (if (zero? m) (bit-shift-left 1 shift) m))\n                  (let [rngs (node-ranges n1)\n                        i    (dec (aget rngs 32))]\n                    (if (zero? i)\n                      (aget rngs 0)\n                      (- (aget rngs i) (aget rngs (dec i))))))\n          ccnt2 (if (regular? n2)\n                  (let [m (mod cnt2 (bit-shift-left 1 shift))]\n                    (if (zero? m) (bit-shift-left 1 shift) m))\n                  (aget (node-ranges n2) 0))\n          next-transferred-leaves (Box. 0)\n          [new-c1 new-c2] (zippath (- shift 5) c1 ccnt1 c2 ccnt2\n                                   next-transferred-leaves)\n          d (.-val next-transferred-leaves)]\n      (set! (.-val transferred-leaves) (+ (.-val transferred-leaves) d))\n      (rebalance shift\n                 (if (identical? c1 new-c1)\n                   n1\n                   (replace-rightmost-child shift n1 new-c1 d))\n                 (+ cnt1 d)\n                 (if new-c2\n                   (if (identical? c2 new-c2)\n                     n2\n                     (replace-leftmost-child shift n2 cnt2 new-c2 d))\n                   (remove-leftmost-child shift n2))\n                 (- cnt2 d)\n                 transferred-leaves))))\n\n(defn squash-nodes [shift n1 cnt1 n2 cnt2]\n  (let [arr1  (.-arr n1)\n        arr2  (.-arr n2)\n        li1   (index-of-nil arr1)\n        li2   (index-of-nil arr2)\n        slots (concat (take li1 arr1) (take li2 arr2))]\n    (if (> (count slots) 32)\n      (array n1 n2)\n      (let [new-rngs (make-array 33)\n            new-arr  (make-array 33)\n            rngs1    (take li1 (if (regular? n1)\n                                 (regular-ranges shift cnt1)\n                                 (node-ranges n1)))\n            rngs2    (take li2 (if (regular? n2)\n                                 (regular-ranges shift cnt2)\n                                 (node-ranges n2)))\n            rngs2    (let [r (last rngs1)]\n                       (map #(+ % r) rngs2))\n            rngs     (concat rngs1 rngs2)]\n        (aset new-arr 32 new-rngs)\n        (loop [i 0 cs (seq slots)]\n          (when cs\n            (aset new-arr i (first cs))\n            (recur (inc i) (next cs))))\n        (loop [i 0 rngs (seq rngs)]\n          (if rngs\n            (do (aset new-rngs i (first rngs))\n                (recur (inc i) (next rngs)))\n            (aset new-rngs 32 i)))\n        (array (->VectorNode nil new-arr) nil)))))\n\n(def peephole-optimization-config (atom {:debug-fn nil}))\n(def peephole-optimization-count (atom 0))\n\n;; TBD: Transducer versions of child-nodes and bounded-grandchildren\n;; are included here for when we are willing to rely upon Clojure\n;; 1.7.0 as the minimum version supported by the core.rrb-vector\n;; library.  They are faster.\n\n#_(defn child-nodes [node]\n  (into [] (comp (take-while (complement nil?))\n                 (take 32))\n        (.-arr node)))\n\n(defn child-nodes [node]\n  (->> (.-arr node)\n       (take-while (complement nil?))\n       (take 32)))\n\n;; (take 33) is just a technique to avoid generating more\n;; grandchildren than necessary.  If there are at least 33, we do not\n;; care how many there are.\n#_(defn bounded-grandchildren [children]\n  (into [] (comp (map child-nodes)\n                 cat\n                 (take 33))\n        children))\n\n(defn bounded-grandchildren [children]\n  (->> children\n       (mapcat child-nodes)\n       (take 33)))\n\n;; TBD: Do functions like last-non-nil-idx and\n;; count-vector-elements-beneath already exist elsewhere in this\n;; library?  It seems like they might.\n\n;; A regular tree node is guaranteed to have only 32-way branching at\n;; all nodes, except perhaps along the right spine, where it can be\n;; partial.  From a regular tree node down, all leaf arrays\n;; (containing vector elements directly) are restricted to contain a\n;; full 32 vector elements.  This code relies on these invariants to\n;; quickly calculate the number of vector elements beneath a regular\n;; node in O(log N) time.\n\n(defn last-non-nil-idx [arr]\n  (loop [i (dec (alength arr))]\n    (if (neg? i)\n      i\n      (if (nil? (aget arr i))\n        (recur (dec i))\n        i))))\n\n(defn count-vector-elements-beneath [node shift]\n  (if (regular? node)\n    (loop [node node\n           shift shift\n           acc 0]\n      (if (zero? shift)\n        (if (nil? node)\n          acc\n          ;; The +32 is for the regular leaf node reached at shift 0\n          (+ acc 32))\n        (let [arr (.-arr node)\n              max-child-idx (last-non-nil-idx arr)\n              num-elems-in-full-child (bit-shift-left 1 shift)]\n          (if (< max-child-idx 0)\n            acc\n            (recur (aget arr max-child-idx)\n                   (- shift 5)\n                   (+ acc (* max-child-idx num-elems-in-full-child)))))))\n    ;; irregular case\n    (let [rngs (node-ranges node)]\n      (aget rngs (dec (aget rngs 32))))))\n\n(defn peephole-optimize-root [v]\n  (let [config @peephole-optimization-config]\n    (if (<= (.-shift v) 10)\n      ;; Tree depth cannot be reduced if shift <= 5.\n      ;; TBD: If shift=10, the grandchildren nodes need to be handled\n      ;; by an am array manager for primitive vectors, which I haven't\n      ;; written code for yet below, but so far this peephole\n      ;; optimizer seems to be working sufficiently well without\n      ;; handling that case.\n      v\n      (let [root (.-root v)\n            children (child-nodes root)\n            grandchildren (bounded-grandchildren children)\n            num-granchildren-bounded (count grandchildren)\n            many-grandchildren? (> num-granchildren-bounded 32)]\n        (if many-grandchildren?\n          ;; If it is possible to reduce tree depth, it requires going\n          ;; deeper than just to the grandchildren, which is beyond\n          ;; what this peephole optimizer is intended to do.\n          v\n          ;; Create a new root node that points directly at the\n          ;; grandchildren, since there are few enough of them.\n          (let [new-arr  (make-array 33)\n                new-rngs (make-array 33)\n                new-root (->VectorNode (.-edit root) new-arr)\n                shift    (.-shift v)\n                grandchild-shift (- shift (* 2 5))]\n            (swap! peephole-optimization-count inc)\n            (loop [idx 0\n                   remaining-gc grandchildren\n                   elem-sum 0]\n              (if-let [remaining-gc (seq remaining-gc)]\n                (let [grandchild (first remaining-gc)\n                      num-elems-this-grandchild (count-vector-elements-beneath\n                                                 grandchild grandchild-shift)\n                      next-elem-sum (+ elem-sum num-elems-this-grandchild)]\n                  (aset new-arr idx grandchild)\n                  (aset new-rngs idx next-elem-sum)\n                  (recur (inc idx) (rest remaining-gc) next-elem-sum))))\n            (aset new-rngs 32 num-granchildren-bounded)\n            (aset new-arr 32 new-rngs)\n            (let [new-v (Vector. (.-cnt v) (- shift 5)\n                                 new-root (.-tail v) (.-meta v) nil)]\n              (when (:debug-fn config)\n                ((:debug-fn config) v new-v))\n              new-v)))))))\n\n;; TBD: I do not know if this implementation actually supports this\n;; many elements in one vector.  What is the limit?  I picked this\n;; number simply to match what I believe is the upper limit for the\n;; Clojure implementation.\n(def max-vector-elements 2147483647)\n\n;; Larger shift values than 64 definitely break assumptions all over\n;; the RRB vector implementation, e.g. (bit-shift-right 255 65)\n;; returns the same result as (bit-shift-right 255 1), I believe\n;; because the shift amount argument is effectively modulo'd by 64.\n;; Larger shift values than 30 are unlikely to make sense, given that\n;; the maximum number of vector elements supported is somewhere near\n;; 2^31-1.\n\n(defn shift-too-large? [v]\n  (> (.-shift v) 30))\n\n;; The maximum number of vector elements in a tree, not counting any\n;; elements in the tail, with a given shift value is:\n;;\n;; (bit-shift-left 1 (+ shift 5))\n;;\n;; It is perfectly normal to have vectors with a root tree node with\n;; only 1 non-nil child, so at a fraction 1/32 of maximum capacity.  I\n;; do not know the exact minimum fraction that RRB vectors as\n;; implemented here should allow, but I suspect it is well over\n;; 1/1024.\n\n(defn poor-branching? [v]\n  (let [tail-off (-tail-offset v)]\n    (if (zero? tail-off)\n      false\n      (let [shift-amount (- (.-shift v) 5)\n            max-capacity-divided-by-1024 (bit-shift-left 1 shift-amount)]\n        (< tail-off max-capacity-divided-by-1024)))))\n\n;; Note 3:\n\n;; Consider measuring several ways in ClojureScript to create a\n;; regular persistent vector from another one, to see which is\n;; fastest, and use it here.\n\n;; TBD: Is there any promise about what metadata catvec returns?\n;; Always the same as on the first argument?\n\n(def fallback-config (atom {:debug-fn nil}))\n(def fallback-to-slow-splice-count1 (atom 0))\n(def fallback-to-slow-splice-count2 (atom 0))\n\n(defn fallback-to-slow-splice-if-needed [v1 v2 splice-result]\n  (let [config @fallback-config]\n    (if (or (shift-too-large? splice-result)\n            (poor-branching? splice-result))\n      (do\n        (dbg (str \"splice-rrbts result had shift \" (.-shift splice-result)\n                  \" and \" (-tail-offset splice-result) \" elements not counting\"\n                  \" the tail. Falling back to slower method of concatenation.\"))\n        (if (poor-branching? v1)\n          ;; The v1 we started with was not good, either.\n          (do\n            (swap! fallback-to-slow-splice-count1 inc)\n            (dbg (str \"splice-rrbts first arg had shift \" (.-shift v1)\n                      \" and \" (-tail-offset v1) \" elements not counting\"\n                      \" the tail.  Building the result from scratch.\"))\n            ;: See Note 3\n            (let [new-splice-result (-> (empty v1) (into v1) (into v2))]\n              (when (:debug-fn config)\n                ((:debug-fn config) splice-result new-splice-result))\n              new-splice-result))\n          ;; Assume that v1 is balanced enough that we can use into to\n          ;; add all elements of v2 to it, without problems.  TBD:\n          ;; That assumption might be incorrect.  Consider checking\n          ;; the result of this, too, and fall back again to the true\n          ;; case above?\n          (let [new-splice-result (into v1 v2)]\n            (swap! fallback-to-slow-splice-count2 inc)\n            (when (:debug-fn config)\n              ((:debug-fn config) splice-result new-splice-result))\n            new-splice-result)))\n      ;; else the fast result is good\n      splice-result)))\n\n(defn splice-rrbts-main [v1 v2]\n  (cond\n    (zero? (count v1)) v2\n    (> (+ (count v1) (count v2)) max-vector-elements)\n    (let [c1 (count v1), c2 (count v2)]\n      (throw (js/Error.\n              (str \"Attempted to concatenate two vectors whose total\"\n                   \" number of elements is \" (+ c1 c2) \", which is\"\n                   \" larger than the maximum number of elements \"\n                   max-vector-elements \" supported in a vector \"))))\n    (< (count v2) rrbt-concat-threshold) (into v1 v2)\n    :else\n    (let [s1 (.-shift v1)\n          s2 (.-shift v2)\n          r1 (.-root v1)\n          o? (overflow? r1 s1 (+ (count v1) (- 32 (alength (.-tail v1)))))\n          r1 (if o?\n               (let [tail      (.-tail v1)\n                     tail-node (->VectorNode nil tail)\n                     reg?      (and (regular? r1) (== (alength tail) 32))\n                     arr       (make-array (if reg? 32 33))]\n                 (aset arr 0 r1)\n                 (aset arr 1 (new-path* s1 tail-node))\n                 (if-not reg?\n                   (let [rngs (make-array 33)]\n                     (aset rngs 32 2)\n                     (aset rngs 0 (- (count v1) (alength tail)))\n                     (aset rngs 1 (count v1))\n                     (aset arr 32 rngs)))\n                 (->VectorNode nil arr))\n               (fold-tail r1 s1\n                          (-tail-offset v1)\n                          (.-tail v1)))\n          s1 (if o? (+ s1 5) s1)\n          r2 (.-root v2)\n          s  (max s1 s2)\n          r1 (shift-from-to r1 s1 s)\n          r2 (shift-from-to r2 s2 s)\n          transferred-leaves (Box. 0)\n          [n1 n2] (zippath s\n                           r1 (count v1)\n                           r2 (- (count v2) (alength (.-tail v2)))\n                           transferred-leaves)\n          d (.-val transferred-leaves)\n          ncnt1   (+ (count v1) d)\n          ncnt2   (- (count v2) (alength (.-tail v2)) d)\n          [n1 n2] (if (identical? n2 r2)\n                    (squash-nodes s n1 ncnt1 n2 ncnt2)\n                    (array n1 n2))\n          ncnt1   (if n2\n                    ncnt1\n                    (+ ncnt1 ncnt2))\n          ncnt2   (if n2\n                    ncnt2\n                    0)]\n      (if n2\n        (let [arr      (make-array 33)\n              new-root (->VectorNode nil arr)]\n          (aset arr 0 n1)\n          (aset arr 1 n2)\n          (aset arr 32 (doto (make-array 33)\n                         (aset 0 ncnt1)\n                         (aset 1 (+ ncnt1 ncnt2))\n                         (aset 32 2)))\n          (Vector. (+ (count v1) (count v2)) (+ s 5) new-root (.-tail v2)\n                   nil nil))\n        (loop [r n1\n               s s]\n          (if (and (> s 5)\n                   (nil? (aget (.-arr r) 1)))\n            (recur (aget (.-arr r) 0) (- s 5))\n            (Vector. (+ (count v1) (count v2)) s r (.-tail v2)\n                     nil nil)))))))\n\n(defn splice-rrbts [v1 v2]\n  (let [r1 (splice-rrbts-main v1 v2)\n        r2 (peephole-optimize-root r1)]\n    (fallback-to-slow-splice-if-needed v1 v2 r2)))\n\n(deftype Transient [^:mutable cnt\n                    ^:mutable shift\n                    ^:mutable root\n                    ^:mutable tail\n                    ^:mutable tidx]\n  ITransientCollection\n  (-conj! [this o]\n    (if ^boolean (.-edit root)\n      (if (< tidx 32)\n        (do (aset tail tidx o)\n            (set! cnt  (inc cnt))\n            (set! tidx (inc tidx))\n            this)\n        (let [tail-node (->VectorNode (.-edit root) tail)\n              new-tail  (make-array 32)]\n          (aset new-tail 0 o)\n          (set! tail new-tail)\n          (set! tidx 1)\n          (if (overflow? root shift cnt)\n            (if (regular? root)\n              (let [new-arr (make-array 32)]\n                (doto new-arr\n                  (aset 0 root)\n                  (aset 1 (new-path tail (.-edit root) shift tail-node)))\n                (set! root  (->VectorNode (.-edit root) new-arr))\n                (set! shift (+ shift 5))\n                (set! cnt   (inc cnt))\n                this)\n              (let [new-arr  (make-array 33)\n                    new-rngs (make-array 33)\n                    new-root (->VectorNode (.-edit root) new-arr)\n                    root-total-range (aget (node-ranges root) 31)]\n                (doto new-arr\n                  (aset 0  root)\n                  (aset 1  (new-path tail (.-edit root) shift tail-node))\n                  (aset 32 new-rngs))\n                (doto new-rngs\n                  (aset 0  root-total-range)\n                  (aset 1  (+ root-total-range 32))\n                  (aset 32 2))\n                (set! root  new-root)\n                (set! shift (+ shift 5))\n                (set! cnt   (inc cnt))\n                this))\n            (let [new-root (push-tail! shift cnt (.-edit root) root tail-node)]\n              (set! root new-root)\n              (set! cnt  (inc cnt))\n              this))))\n      (throw (js/Error. \"conj! after persistent!\"))))\n\n  (-persistent! [this]\n    (if ^boolean (.-edit root)\n      (do (set! (.-edit root) nil)\n          (let [trimmed-tail (make-array tidx)]\n            (array-copy tail 0 trimmed-tail 0 tidx)\n            (Vector. cnt shift root trimmed-tail nil nil)))\n      (throw (js/Error. \"persistent! called twice\"))))\n\n  ITransientAssociative\n  (-assoc! [this key val]\n    (-assoc-n! this key val))\n\n  ITransientVector\n  (-assoc-n! [this i val]\n    (if ^boolean (.-edit root)\n      (cond\n        (and (<= 0 i) (< i cnt))\n        (let [tail-off (- cnt tidx)]\n          (if (<= tail-off i)\n            (aset tail (- i tail-off) val)\n            (set! root (do-assoc! shift (.-edit root) root i val)))\n          this)\n\n        (== i cnt) (-conj! this val)\n\n        :else (vector-index-out-of-bounds i cnt))\n      (throw (js/Error. \"assoc! after persistent!\"))))\n\n  (-pop! [this]\n    (if ^boolean (.-edit root)\n      (cond\n        (zero? cnt)\n        (throw (js/Error. \"Can't pop empty vector\"))\n\n        (== 1 cnt)\n        (do (set! cnt  0)\n            (set! tidx 0)\n            (aset tail 0 nil)\n            this)\n\n        (> tidx 1)\n        (do (set! cnt  (dec cnt))\n            (set! tidx (dec tidx))\n            (aset tail tidx nil)\n            this)\n\n        :else\n        (let [new-tail-base (-array-for this (- cnt 2))\n              new-tail      (editable-tail new-tail-base)\n              new-tidx      (alength new-tail-base)\n              new-root      (pop-tail! shift cnt (.-edit root) root)]\n          (cond\n            (nil? new-root)\n            (do (set! cnt  (dec cnt))\n                (set! root (ensure-editable (.-edit root) empty-node))\n                (set! tail new-tail)\n                (set! tidx new-tidx)\n                this)\n\n            (and (> shift 5)\n                 (nil? (aget (.-arr new-root) 1)))\n            (do (set! cnt   (dec cnt))\n                (set! shift (- shift 5))\n                (set! root  (ensure-editable (.-edit root)\n                                             (aget (.-arr new-root) 0)))\n                (set! tail  new-tail)\n                (set! tidx  new-tidx)\n                this)\n\n            :else\n            (do (set! cnt  (dec cnt))\n                (set! root new-root)\n                (set! tail new-tail)\n                (set! tidx new-tidx)\n                this))))\n      (throw (js/Error. \"count after persistent!\"))))\n\n  ICounted\n  (-count [this]\n    (if ^boolean (.-edit root)\n      cnt\n      (throw (js/Error. \"count after persistent!\"))))\n\n  IVecImpl\n  (-tail-offset [this]\n    (- cnt tidx))\n\n  (-array-for [this i]\n    (if (and (<= 0 i) (< i cnt))\n      (if (>= i (-tail-offset this))\n        tail\n        (loop [i i node root shift shift]\n          (if (zero? shift)\n            (.-arr node)\n            (if (regular? node)\n              (loop [node  (aget (.-arr node)\n                                 (bit-and (bit-shift-right i shift) 0x1f))\n                     shift (- shift 5)]\n                (if (zero? shift)\n                  (.-arr node)\n                  (recur (aget (.-arr node)\n                               (bit-and (bit-shift-right i shift) 0x1f))\n                         (- shift 5))))\n              (let [rngs (node-ranges node)\n                    j    (loop [j (bit-and (bit-shift-right i shift) 0x1f)]\n                           (if (< i (aget rngs j))\n                             j\n                             (recur (inc j))))\n                    i    (if (pos? j)\n                           (- i (aget rngs (dec j)))\n                           i)]\n                (recur i\n                       (aget (.-arr node) j)\n                       (- shift 5)))))))\n      (vector-index-out-of-bounds i cnt))))\n","~:reader-features",["^F",["~:cljs"]],"~:used-var-namespaces",["^F",["^S","^W","~$js","^X","^M","^U","^V","^T"]],"~:cljc",false,"~:source-map-compact",["^ ","mappings","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","names",["clojure.core.rrb-vector.rrbt/rrbt-concat-threshold","clojure.core.rrb-vector.rrbt/max-extra-search-steps","clojure$core$rrb-vector$rrbt$IVecImpl$_tail_offset$dyn","x__5350__auto__","m__5351__auto__","clojure.core.rrb-vector.rrbt/-tail-offset","goog/typeOf","m__5349__auto__","cljs.core/missing-protocol","clojure$core$rrb-vector$rrbt$IVecImpl$_array_for$dyn","clojure.core.rrb-vector.rrbt/-array-for","clojure.core.rrb-vector.rrbt/IVecImpl","v","i","clojure$core$rrb-vector$rrbt$AsRRBT$_as_rrbt$dyn","clojure.core.rrb-vector.rrbt/-as-rrbt","clojure.core.rrb-vector.rrbt/AsRRBT","this__5287__auto__","writer__5288__auto__","opt__5289__auto__","cljs.core/-write","clojure.core.rrb-vector.rrbt/RRBChunkedSeq","clojure.core.rrb-vector.rrbt/->RRBChunkedSeq","vec","node","off","meta","__hash","coll","cljs.core/pr-str*","this","writer","opts","cljs.core/pr-sequential-writer","cljs.core/pr-writer","m","clojure.core.rrb-vector.rrbt/rrb-chunked-seq","other","cljs.core/equiv-sequential","s","G__10606","G__10607","G__10608","G__10609","G__10594","G__10595","G__10596","G__10597","o","cljs.core/cons","cljs.core/with-meta","cljs.core/List","cljs.core.array_chunk","l","cljs.core/-count","G__10619","G__10620","G__10621","G__10626","G__10627","G__10628","h__5111__auto__","cljs.core/hash-ordered-coll","f","cljs.core.ci_reduce","cljs.core.subvec","cljs.core/count","start","var_args","G__10639","js/Error","clojure.core.rrb-vector.rrbt/slice-right","shift","end","arr","new-arr","js/Array","cljs.core/array-copy","cljs.core/->VectorNode","reg?","clojure.core.rrb-vector.nodes/regular?","rngs","clojure.core.rrb-vector.nodes/node-ranges","j","child-end","ce","cljs.core/mod","new-child","G__10655","G__10656","G__10657","regular-child?","new-child-rng","clojure.core.rrb-vector.nodes/last-range","new-rngs","step","n__5593__auto__","clojure.core.rrb-vector.rrbt/slice-left","new-len","len","child-start","x__5090__auto__","y__5091__auto__","capped-end","G__10669","G__10670","G__10671","G__10672","rng0","r","cljs.core/PROTOCOL_SENTINEL","unused__10318__auto__","self__","G__10747","args10695","cljs.core/aclone","clojure.core.rrb-vector.rrbt/Vector","clojure.core.rrb-vector.rrbt/->Vector","cnt","root","tail","that","cljs.core.array_seq","clojure.core.rrb_vector.rrbt.rrb_chunked_seq","_","tail-off","idx","cljs.core/vector-index-out-of-bounds","not-found","val","tail-len","new-tail","tail-node","clojure.core.rrb-vector.nodes/overflow?","new-root","G__10739","clojure.core.rrb-vector.trees/new-path","root-total-range","G__10741","G__10742","clojure.core.rrb-vector.trees/push-tail","cljs.core/PersistentVector","cljs.core/-with-meta","root-cnt","clojure.core.rrb-vector.trees/pop-tail","clojure.core.rrb-vector.nodes/empty-node","clojure.core.rrb-vector.trees/do-assoc","cljs.core/RSeq","k","init","lim","G__10699","G__10700","G__10701","cljs.core/deref","cljs.core/reduced?","cljs.core.compare_indexed","G__10717","G__10718","G__10719","G__10720","G__10721","clojure.core.rrb-vector.rrbt/->Transient","clojure.core.rrb-vector.transients/editable-root","clojure.core.rrb-vector.transients/editable-tail","new-cnt","cljs.core/empty","tail-cut?","G__10748","G__10749","clojure.core.rrb-vector.rrbt/splice-rrbts","cljs.core/meta","cljs.core/Subvec","clojure.core.rrb-vector.protocols/-slicev","clojure.core.rrb-vector.rrbt/shift-from-to","from","to","G__10766","G__10767","G__10768","clojure.core.rrb-vector.rrbt/slot-count","clojure.core.rrb-vector.nodes/index-of-nil","clojure.core.rrb-vector.rrbt/subtree-branch-count","cs","sbc","temp__5802__auto__","child","clojure.core.rrb-vector.rrbt/leaf-seq","p1__10779#","cljs.core.mapcat","cljs.core.take","clojure.core.rrb-vector.rrbt/rebalance-leaves","n1","cnt1","n2","cnt2","transferred-leaves","slc1","slc2","a","sbc1","sbc2","p","e","cljs.core/quot","new-n1","bs","cljs.core.partition_all","cljs.core.concat","temp__5804__auto__","cljs.core/seq","xs__6360__auto__","cljs.core/first","block","xs","cljs.core/next","clojure.core.rrb-vector.nodes/regular-ranges","new-arr1","new-arr2","new-n2","clojure.core.rrb-vector.rrbt/child-seq","cseq","c","gcs","cljs.core.map","cljs.core/list","cljs.core/-","clojure.core.rrb-vector.rrbt/rebalance","vec__10784","cljs.core.nth","gc","gcr","new-rngs1","new-rngs2","vec__10787","tbs","li","d","clojure.core.rrb-vector.rrbt/zippath","vec__10790","c1","clojure.core.rrb-vector.nodes/last-child","c2","clojure.core.rrb-vector.nodes/first-child","ccnt1","ccnt2","next-transferred-leaves","cljs.core/Box","new-c1","new-c2","G__10793","G__10794","G__10795","G__10796","G__10797","G__10798","clojure.core.rrb-vector.nodes/replace-rightmost-child","clojure.core.rrb-vector.nodes/replace-leftmost-child","clojure.core.rrb-vector.nodes/remove-leftmost-child","clojure.core.rrb-vector.rrbt/squash-nodes","arr1","arr2","li1","li2","slots","rngs1","rngs2","cljs.core/last","p1__10799#","clojure.core.rrb-vector.rrbt/peephole-optimization-config","cljs.core.atom","clojure.core.rrb-vector.rrbt/peephole-optimization-count","clojure.core.rrb-vector.rrbt/child-nodes","cljs.core.take_while","cljs.core/complement","cljs.core/nil?","clojure.core.rrb-vector.rrbt/bounded-grandchildren","children","clojure.core.rrb-vector.rrbt/last-non-nil-idx","clojure.core.rrb-vector.rrbt/count-vector-elements-beneath","acc","max-child-idx","num-elems-in-full-child","clojure.core.rrb-vector.rrbt/peephole-optimize-root","config","grandchildren","num-granchildren-bounded","many-grandchildren?","grandchild-shift","cljs.core.swap_BANG_","cljs.core/inc","remaining-gc","elem-sum","grandchild","num-elems-this-grandchild","next-elem-sum","cljs.core/rest","new-v","fexpr__10809","clojure.core.rrb-vector.rrbt/max-vector-elements","clojure.core.rrb-vector.rrbt/shift-too-large?","clojure.core.rrb-vector.rrbt/poor-branching?","shift-amount","max-capacity-divided-by-1024","clojure.core.rrb-vector.rrbt/fallback-config","clojure.core.rrb-vector.rrbt/fallback-to-slow-splice-count1","clojure.core.rrb-vector.rrbt/fallback-to-slow-splice-count2","clojure.core.rrb-vector.rrbt/fallback-to-slow-splice-if-needed","v1","v2","splice-result","new-splice-result","cljs.core.into","fexpr__10829","fexpr__10830","clojure.core.rrb-vector.rrbt/splice-rrbts-main","vec__10837","vec__10840","s1","s2","r1","o?","clojure.core.rrb-vector.nodes/new-path*","clojure.core.rrb-vector.nodes/fold-tail","r2","x__5087__auto__","y__5088__auto__","ncnt1","ncnt2","G__10855","clojure.core.rrb-vector.rrbt/Transient","tidx","G__10871","G__10877","G__10879","clojure.core.rrb-vector.transients/push-tail!","trimmed-tail","key","clojure.core.rrb-vector.transients/do-assoc!","new-tail-base","new-tidx","clojure.core.rrb-vector.transients/pop-tail!","clojure.core.rrb-vector.transients/ensure-editable"]],"~:used-vars",["^F",["~$clojure.core.rrb-vector.rrbt/slice-left","~$cljs.core/mapcat","~$clojure.core.rrb-vector.nodes/empty-node","~$cljs.core/PROTOCOL_SENTINEL","~$cljs.core/rest","~$clojure.core.rrb-vector.rrbt/leaf-seq","~$clojure.core.rrb-vector.nodes/overflow?","~$clojure.core.rrb-vector.rrbt/last-non-nil-idx","~$clojure.core.rrb-vector.rrbt/fallback-config","~$clojure.core.rrb-vector.rrbt/->Vector","~$cljs.core/ci-reduce","~$clojure.core.rrb-vector.rrbt/count-vector-elements-beneath","~$clojure.core.rrb-vector.rrbt/child-seq","~$clojure.core.rrb-vector.rrbt/squash-nodes","~$clojure.core.rrb-vector.rrbt/slice-right","~$cljs.core/pr-sequential-writer","~$clojure.core.rrb-vector.rrbt/-tail-offset","~$clojure.core.rrb-vector.rrbt/Transient","~$clojure.core.rrb-vector.transients/push-tail!","~$clojure.core.rrb-vector.rrbt/poor-branching?","~$clojure.core.rrb-vector.trees/pop-tail","~$cljs.core/take-while","~$clojure.core.rrb-vector.transients/editable-root","~$clojure.core.rrb-vector.rrbt/rrbt-concat-threshold","~$cljs.core/-write","~$cljs.core/pr-writer","~$cljs.core/hash-ordered-coll","~$clojure.core.rrb-vector.transients/do-assoc!","~$clojure.core.rrb-vector.rrbt/rebalance","~$cljs.core/count","~$cljs.core/deref","~$cljs.core/-assoc-n!","~$goog/typeOf","~$cljs.core/seq","~$clojure.core.rrb-vector.rrbt/->RRBChunkedSeq","~$cljs.core/take","~$cljs.core/aclone","~$cljs.core/partition-all","~$cljs.core/last","~$clojure.core.rrb-vector.nodes/replace-rightmost-child","~$clojure.core.rrb-vector.rrbt/fallback-to-slow-splice-if-needed","~$cljs.core/quot","~$cljs.core/atom","~$clojure.core.rrb-vector.rrbt/fallback-to-slow-splice-count2","~$cljs.core/Subvec","~$cljs.core/-with-meta","~$cljs.core/concat","~$cljs.core/pr-str*","~$clojure.core.rrb-vector.rrbt/AsRRBT","~$clojure.core.rrb-vector.nodes/last-range","~$clojure.core.rrb-vector.nodes/replace-leftmost-child","~$cljs.core/compare-indexed","~$clojure.core.rrb-vector.protocols/-slicev","~$clojure.core.rrb-vector.rrbt/splice-rrbts","~$clojure.core.rrb-vector.trees/push-tail","~$cljs.core/-","~$cljs.core/into","~$cljs.core/array-seq","~$cljs.core/-count","~$cljs.core/array-chunk","~$cljs.core/-conj","~$cljs.core/with-meta","~$cljs.core/map","~$clojure.core.rrb-vector.transients/ensure-editable","~$cljs.core/-assoc-n","~$cljs.core/PersistentVector","~$clojure.core.rrb-vector.nodes/new-path*","~$cljs.core/List","~$cljs.core/empty","~$cljs.core/swap!","~$clojure.core.rrb-vector.rrbt/max-vector-elements","~$cljs.core/-chunked-next","~$cljs.core/equiv-sequential","~$clojure.core.rrb-vector.rrbt/shift-too-large?","~$clojure.core.rrb-vector.rrbt/peephole-optimization-count","~$clojure.core.rrb-vector.rrbt/splice-rrbts-main","~$clojure.core.rrb-vector.nodes/remove-leftmost-child","~$clojure.core.rrb-vector.nodes/last-child","~$js/Array","~$cljs.core/-nth","~$clojure.core.rrb-vector.rrbt/fallback-to-slow-splice-count1","~$clojure.core.rrb-vector.rrbt/->Transient","~$cljs.core/RSeq","~$clojure.core.rrb-vector.trees/new-path","~$cljs.core/mod","~$cljs.core/missing-protocol","~$clojure.core.rrb-vector.trees/do-assoc","~$clojure.core.rrb-vector.rrbt/shift-from-to","~$cljs.core/subvec","~$clojure.core.rrb-vector.rrbt/peephole-optimization-config","~$clojure.core.rrb-vector.nodes/regular?","~$cljs.core/reduced?","~$cljs.core/nil?","~$cljs.core/nth","~$cljs.core/meta","~$clojure.core.rrb-vector.rrbt/zippath","~$clojure.core.rrb-vector.rrbt/rrb-chunked-seq","~$clojure.core.rrb-vector.rrbt/slot-count","~$clojure.core.rrb-vector.nodes/first-child","~$cljs.core/next","~$cljs.core/->VectorNode","~$clojure.core.rrb-vector.transients/editable-tail","~$clojure.core.rrb-vector.nodes/fold-tail","~$clojure.core.rrb-vector.rrbt/child-nodes","~$clojure.core.rrb-vector.rrbt/subtree-branch-count","~$clojure.core.rrb-vector.rrbt/-array-for","~$cljs.core/not","~$cljs.core/complement","~$clojure.core.rrb-vector.rrbt/-as-rrbt","~$cljs.core/cons","~$clojure.core.rrb-vector.rrbt/Vector","~$clojure.core.rrb-vector.transients/pop-tail!","~$clojure.core.rrb-vector.rrbt/peephole-optimize-root","~$clojure.core.rrb-vector.rrbt/rebalance-leaves","~$cljs.core/-conj!","~$clojure.core.rrb-vector.rrbt/bounded-grandchildren","~$cljs.core/first","~$clojure.core.rrb-vector.nodes/regular-ranges","~$clojure.core.rrb-vector.rrbt/RRBChunkedSeq","~$cljs.core/list","~$clojure.core.rrb-vector.nodes/index-of-nil","~$cljs.core/array-copy","~$cljs.core/vector-index-out-of-bounds","~$clojure.core.rrb-vector.nodes/node-ranges","~$js/Error","~$clojure.core.rrb-vector.rrbt/IVecImpl","~$cljs.core/inc","~$cljs.core/-chunked-rest","~$clojure.core.rrb-vector.rrbt/max-extra-search-steps","~$cljs.core/Box"]]],"~:cache-keys",["~#cmap",[["^1S","goog/dom/tagname.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^F",[]],"~:deps-syms",["^X","~$goog.dom.HtmlElement"]]],["^1S","goog/html/trustedtypes.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X"]]],["^1S","goog/labs/useragent/browser.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","~$goog.labs.userAgent.util","~$goog.labs.userAgent.highEntropy.highEntropyValue","~$goog.asserts","~$goog.string.internal","~$goog.labs.userAgent.highEntropy.highEntropyData","~$goog.labs.userAgent"]]],["^1S","goog/html/safeurl.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","^5<","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.string.Const","~$goog.string.TypedString","^5="]]],["^1S","goog/array/array.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","^5<"]]],["^1S","clojure/core/rrb_vector/rrbt.cljs"],["0404feea925608b921b56acd11d3b187a0d33fe4","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","^W","^S","^T","^U","^V"]]],["^1S","goog/debug/error.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X"]]],["^1S","clojure/core/rrb_vector/trees.cljs"],["0404feea925608b921b56acd11d3b187a0d33fe4","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","^W","^T"]]],["^1S","goog/flags/flags.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X"]]],["^1S","clojure/core/rrb_vector/nodes.cljs"],["0404feea925608b921b56acd11d3b187a0d33fe4","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","^W"]]],["^1S","goog/dom/nodetype.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X"]]],["^1S","goog/labs/useragent/highentropy/highentropyvalue.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","^5:","^5="]]],["^1S","clojure/core/rrb_vector/transients.cljs"],["0404feea925608b921b56acd11d3b187a0d33fe4","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","^W","^T","^U"]]],["^1S","goog/string/typedstring.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X"]]],["^1S","goog/object/object.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X"]]],["^1S","goog/dom/asserts.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","^5<"]]],"~:SHADOW-TIMESTAMP",[1744140476000,1744140476000,1744140474000],["^1S","goog/math/long.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","^5<","~$goog.reflect"]]],["^1S","goog/html/trustedresourceurl.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","^5<","~$goog.fs.blob","^5@","~$goog.html.SafeScript","~$goog.html.trustedtypes","^5B","^5C"]]],["^1S","goog/string/internal.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X"]]],["^1S","goog/functions/functions.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X"]]],["^1S","goog/html/safestyle.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","^5B","~$goog.html.SafeUrl","^5C","^5<","^5="]]],["^1S","goog/dom/safe.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","^5<","~$goog.asserts.dom","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","^5G","~$goog.html.SafeStyle","^5I","^5A","~$goog.html.uncheckedconversions","^5B","^5="]]],["^1S","goog/asserts/dom.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","~$goog.dom.TagName","^5<","~$goog.dom.element"]]],["^1S","goog/html/safehtml.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","^5B","^5G","^5N","~$goog.html.SafeStyleSheet","^5I","^5P","^5A","^5C","^5<","~$goog.labs.userAgent.browser","~$goog.array","~$goog.object","^5=","~$goog.dom.tags","^5H"]]],["^1S","goog/dom/tags.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","^5U"]]],["^1S","goog/fs/blob.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X"]]],["^1S","goog/asserts/asserts.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^1S","goog/uri/uri.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","^5T","^5<","~$goog.collections.maps","~$goog.string","~$goog.structs","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^1S","goog/labs/useragent/highentropy/highentropydata.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","^5;"]]],["^1S","goog/collections/maps.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X"]]],["^1S","goog/fs/url.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X"]]],["^1S","goog/base.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",[]]],["^1S","goog/structs/structs.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","^5T","^5U"]]],["^1S","goog/string/string.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","~$goog.dom.safe","^5O","^5B","^5="]]],["^1S","clojure/core/rrb_vector/protocols.cljs"],["0404feea925608b921b56acd11d3b187a0d33fe4","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","^W"]]],["^1S","goog/reflect/reflect.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X"]]],["^1S","goog/labs/useragent/util.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","^5=","^5?"]]],["^1S","goog/string/stringbuffer.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X"]]],["^1S","goog/labs/useragent/useragent.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","~$goog.flags"]]],["^1S","goog/dom/element.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","^5X","^5P"]]],["^1S","goog/html/uncheckedconversions.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","^5<","^5M","^5G","^5N","^5R","^5I","^5A","^5B","^5="]]],["^1S","goog/dom/htmlelement.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X"]]],["^1S","cljs/core.cljs"],["b89362aeac5c1cafea76c798929ee5d385c461d8","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","~$goog.math.Long","~$goog.math.Integer","^5Z","^5U","^5T","~$goog.Uri","~$goog.string.StringBuffer"]]],["^1S","goog/html/safescript.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","^5B","^5C","^5H","^5<"]]],["^1S","goog/html/safestylesheet.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","^5B","^5N","^5C","^5U","^5<","^5="]]],["^1S","goog/math/integer.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","^5E"]]],["^1S","goog/uri/utils.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","^5<","^5Z"]]],["^1S","goog/string/const.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^55",["^ ","^56",null,"^57",["^F",[]],"^58",["^X","^5<","^5C"]]]]],"~:clj-info",["^ ","jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/source_map/base64_vlq.clj",1744140474000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/compiler.cljc",1744140474000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/analyzer/passes/and_or.cljc",1744140474000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/vendor/clojure/tools/reader/impl/inspect.clj",1744140474000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/core.clj",1744140473000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/core.rrb-vector/0.1.2/core.rrb-vector-0.1.2.jar!/clojure/core/rrb_vector/macros.clj",1744140475000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/string.clj",1744140473000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/tagged_literals.cljc",1744140474000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/vendor/clojure/tools/reader/default_data_readers.clj",1744140474000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/env.cljc",1744140474000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/source_map.clj",1744140474000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/instant.clj",1744140474000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/source_map/base64.clj",1744140474000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/vendor/clojure/tools/reader.clj",1744140474000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/externs.clj",1744140474000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/core.cljc",1744140474000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/edn.clj",1744140473000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/instant.clj",1744140473000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/analyzer/impl/namespaces.cljc",1744140474000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/analyzer/passes.cljc",1744140474000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/java/io.clj",1744140473000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/util.cljc",1744140474000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/vendor/clojure/tools/reader/impl/errors.clj",1744140474000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/js_deps.cljc",1744140474000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/vendor/clojure/data/json.clj",1744140474000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/analyzer.cljc",1744140474000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/analyzer/impl.cljc",1744140474000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/set.clj",1744140473000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojurescript/1.11.132/clojurescript-1.11.132.jar!/cljs/vendor/clojure/tools/reader/reader_types.clj",1744140474000,"jar:file:/Users/dr.breslove/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/pprint.clj",1744140473000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",9,"^8",5,"^9",9,"^:",33],"^;",["^ ","^<","^=","^>","^?","^@","^A"],"~:shadow/protocol-prefixes",["^F",["clojure$core$rrb-vector$rrbt$IVecImpl$","clojure$core$rrb-vector$rrbt$AsRRBT$"]],"^B",["^ ","^C","^D"],"^E",["^F",["^G","^H","^I","^J","^K"]],"^L","^M","^N",["^ "],"^Q",null,"^R",["^ ","^S","^S","^T","^T","^U","^U","^V","^V","^W","^W","^X","^X"],"^Y",["^F",["^Z","^["]],"~:shadow/js-access-global",["^F",["Error","Array"]],"^10",["^ ","^11","^V","^12","^V","^13","^V","^14","^T","^15","^V","^G","^U","^16","^T","^17","^T","^18","^T","^19","^T","^1:","^T","^H","^U","^1;","^V","^I","^U","^1<","^T","^1=","^S","^1>","^T","^1?","^S","^J","^U","^1@","^T","^1A","^T","^1B","^T","^1C","^T","^1D","^S","^1E","^T","^1F","^S","^1G","^V","^1H","^T"],"~:defs",["^ ","~$shift-from-to",["^ ","~:protocol-inline",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",629,"^8",7,"^9",629,"^:",20,"~:arglists",["^1J",["~$quote",["^1J",[["~$node","~$from","~$to"]]]]]],"^L","^44","^6","clojure/core/rrb_vector/rrbt.cljs","^:",20,"~:method-params",["^1J",[["^74","^75","^76"]]],"~:protocol-impl",null,"~:arglists-meta",["^1J",[null,null]],"^8",1,"~:variadic?",false,"^7",629,"^9",629,"~:max-fixed-arity",3,"~:fn-var",true,"^72",["^1J",["^73",["^1J",[["^74","^75","^76"]]]]]],"~$peephole-optimization-config",["^ ","^L","^46","^6","clojure/core/rrb_vector/rrbt.cljs","^7",908,"^8",1,"^9",908,"^:",34,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",908,"^8",6,"^9",908,"^:",34],"~:tag","~$cljs.core/Atom"],"~$peephole-optimization-count",["^ ","^L","^3S","^6","clojure/core/rrb_vector/rrbt.cljs","^7",909,"^8",1,"^9",909,"^:",33,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",909,"^8",6,"^9",909,"^:",33],"^7>","^7?"],"~$splice-rrbts-main",["^ ","^71",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",1111,"^8",7,"^9",1111,"^:",24,"^72",["^1J",["^73",["^1J",[["~$v1","~$v2"]]]]]],"^L","^3T","^6","clojure/core/rrb_vector/rrbt.cljs","^:",24,"^77",["^1J",[["^7B","^7C"]]],"^78",null,"^79",["^1J",[null,null]],"^8",1,"^7:",false,"^7",1111,"~:ret-tag",["^F",[null,"~$clj","~$any","^4K"]],"^9",1111,"^7;",2,"^7<",true,"^72",["^1J",["^73",["^1J",[["^7B","^7C"]]]]]],"~$slot-count",["^ ","^71",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",650,"^8",7,"^9",650,"^:",17,"^72",["^1J",["^73",["^1J",[["^74","~$shift"]]]]]],"^L","^4>","^6","clojure/core/rrb_vector/rrbt.cljs","^:",17,"^77",["^1J",[["^74","^7H"]]],"^78",null,"^79",["^1J",[null,null]],"^8",1,"^7:",false,"^7",650,"^7D",["^F",["^7F","~$number"]],"^9",650,"^7;",2,"^7<",true,"^72",["^1J",["^73",["^1J",[["^74","^7H"]]]]]],"~$zippath",["^ ","^71",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",841,"^8",7,"^9",841,"^:",14,"^72",["^1J",["^73",["^1J",[["^7H","~$n1","~$cnt1","~$n2","~$cnt2","~$transferred-leaves"]]]]]],"^L","^4<","^6","clojure/core/rrb_vector/rrbt.cljs","^:",14,"^77",["^1J",[["^7H","^7K","^7L","^7M","^7N","^7O"]]],"^78",null,"^79",["^1J",[null,null]],"^8",1,"^7:",false,"^7",841,"^7D","~$array","^9",841,"^7;",6,"^7<",true,"^72",["^1J",["^73",["^1J",[["^7H","^7K","^7L","^7M","^7N","^7O"]]]]]],"~$rrb-chunked-seq",["^ ","^71",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",125,"^8",7,"^9",125,"^:",22,"^72",["^1J",["^73",["^1J",[["~$vec","~$i","~$off"],["^7R","^74","~$i","^7S"],["^7R","^74","~$i","^7S","~$meta"]]]]],"~:top-fn",["^ ","^7:",false,"~:fixed-arity",5,"^7;",5,"^77",[["^7R","~$i","^7S"],["^7R","^74","~$i","^7S"],["^7R","^74","~$i","^7S","^7T"]],"^72",["^1J",[["^7R","~$i","^7S"],["^7R","^74","~$i","^7S"],["^7R","^74","~$i","^7S","^7T"]]],"^79",["^1J",[null,null,null]]]],"^L","^4=","^6","clojure/core/rrb_vector/rrbt.cljs","^:",22,"^7U",["^ ","^7:",false,"^7V",5,"^7;",5,"^77",[["^7R","~$i","^7S"],["^7R","^74","~$i","^7S"],["^7R","^74","~$i","^7S","^7T"]],"^72",["^1J",[["^7R","~$i","^7S"],["^7R","^74","~$i","^7S"],["^7R","^74","~$i","^7S","^7T"]]],"^79",["^1J",[null,null,null]]],"^77",[["^7R","~$i","^7S"],["^7R","^74","~$i","^7S"],["^7R","^74","~$i","^7S","^7T"]],"^78",null,"^7V",5,"^79",["^1J",[null,null,null]],"^8",1,"^7:",false,"~:methods",[["^ ","^7V",3,"^7:",false,"^7>","^4S"],["^ ","^7V",4,"^7:",false,"^7>","^4S"],["^ ","^7V",5,"^7:",false,"^7>","^4S"]],"^7",125,"^9",125,"^7;",5,"^7<",true,"^72",["^1J",[["^7R","~$i","^7S"],["^7R","^74","~$i","^7S"],["^7R","^74","~$i","^7S","^7T"]]]],"~$-as-rrbt",["^ ","^71",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",34,"^8",4,"^9",34,"^:",12,"~:protocol","^39","~:doc",null,"^72",["^1J",["^73",["^1J",[["~$v"]]]]]],"^7Y","^39","^L","^4I","^6","clojure/core/rrb_vector/rrbt.cljs","^:",12,"^77",["^1J",[["~$v"]]],"^78",null,"^79",["^1J",[null,null]],"^8",1,"^7:",false,"^7",33,"^7D","^7F","^9",34,"^7;",1,"^7<",true,"^72",["^1J",["^73",["^1J",[["~$v"]]]]],"^7Z",null],"~$child-nodes",["^ ","^71",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",921,"^8",7,"^9",921,"^:",18,"^72",["^1J",["^73",["^1J",[["^74"]]]]]],"^L","^4D","^6","clojure/core/rrb_vector/rrbt.cljs","^:",18,"^77",["^1J",[["^74"]]],"^78",null,"^79",["^1J",[null,null]],"^8",1,"^7:",false,"^7",921,"^7D","~$cljs.core/LazySeq","^9",921,"^7;",1,"^7<",true,"^72",["^1J",["^73",["^1J",[["^74"]]]]]],"~$AsRRBT",["^ ","^5",["^ ","~:protocol-symbol",true,"^6","clojure/core/rrb_vector/rrbt.cljs","^:",20,"^8",14,"^7",33,"~:protocol-info",["^ ","^7W",["^ ","^7X",[["~$v"]]]],"^9",33,"~:sigs",["^ ","~:-as-rrbt",["^ ","^L","^7X","^72",["^1J",[["~$v"]]],"^7Z",null]],"~:jsdoc",["^1J",["@interface"]]],"^82",true,"^L","^39","^6","clojure/core/rrb_vector/rrbt.cljs","^:",20,"^8",1,"^7",33,"^83",["^ ","^7W",["^ ","^7X",[["~$v"]]]],"~:info",null,"^9",33,"^7>","^7F","^84",["^ ","^85",["^ ","^L","^7X","^72",["^1J",[["~$v"]]],"^7Z",null]],"~:impls",["^F",["^35","^3J","^4K"]],"^86",["^1J",["@interface"]]],"~$fallback-to-slow-splice-count2",["^ ","^L","^34","^6","clojure/core/rrb_vector/rrbt.cljs","^7",1076,"^8",1,"^9",1076,"^:",36,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",1076,"^8",6,"^9",1076,"^:",36],"^7>","^7?"],"~$bounded-grandchildren",["^ ","^71",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",935,"^8",7,"^9",935,"^:",28,"^72",["^1J",["^73",["^1J",[["~$children"]]]]]],"^L","^4P","^6","clojure/core/rrb_vector/rrbt.cljs","^:",28,"^77",["^1J",[["^8;"]]],"^78",null,"^79",["^1J",[null,null]],"^8",1,"^7:",false,"^7",935,"^7D","^80","^9",935,"^7;",1,"^7<",true,"^72",["^1J",["^73",["^1J",[["^8;"]]]]]],"~$max-vector-elements",["^ ","^L","^3O","^6","clojure/core/rrb_vector/rrbt.cljs","^7",1033,"^8",1,"^9",1033,"^:",25,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",1033,"^8",6,"^9",1033,"^:",25],"^7>","^7I"],"~$shift-too-large?",["^ ","^71",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",1043,"^8",7,"^9",1043,"^:",23,"^72",["^1J",["^73",["^1J",[["~$v"]]]]]],"^L","^3R","^6","clojure/core/rrb_vector/rrbt.cljs","^:",23,"^77",["^1J",[["~$v"]]],"^78",null,"^79",["^1J",[null,null]],"^8",1,"^7:",false,"^7",1043,"^7D","~$boolean","^9",1043,"^7;",1,"^7<",true,"^72",["^1J",["^73",["^1J",[["~$v"]]]]]],"~$peephole-optimize-root",["^ ","^71",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",982,"^8",7,"^9",982,"^:",29,"^72",["^1J",["^73",["^1J",[["~$v"]]]]]],"^L","^4M","^6","clojure/core/rrb_vector/rrbt.cljs","^:",29,"^77",["^1J",[["~$v"]]],"^78",null,"^79",["^1J",[null,null]],"^8",1,"^7:",false,"^7",982,"^7D",["^F",[null,"^4K"]],"^9",982,"^7;",1,"^7<",true,"^72",["^1J",["^73",["^1J",[["~$v"]]]]]],"~$slice-left",["^ ","^71",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",186,"^8",7,"^9",186,"^:",17,"^72",["^1J",["^73",["^1J",[["^74","^7H","~$start","~$end"]]]]]],"^L","^25","^6","clojure/core/rrb_vector/rrbt.cljs","^:",17,"^77",["^1J",[["^74","^7H","^8A","^8B"]]],"^78",null,"^79",["^1J",[null,null]],"^8",1,"^7:",false,"^7",186,"^7D",["^F",["~$cljs.core/VectorNode","~$clj-nil"]],"^9",186,"^7;",4,"^7<",true,"^72",["^1J",["^73",["^1J",[["^74","^7H","^8A","^8B"]]]]]],"~$->Transient",["^ ","^71",null,"^5",["^ ","~:protocols",["^F",["~$cljs.core/ICounted","~$cljs.core/ITransientCollection","~$cljs.core/ITransientVector","~$cljs.core/ITransientAssociative","^4Z"]],"^6","clojure/core/rrb_vector/rrbt.cljs","^:",19,"^8",10,"~:factory","~:positional","^7",1190,"^9",1190,"^72",["^1J",["^73",["^1J",[["~$cnt","^7H","~$root","~$tail","~$tidx"]]]]],"~:skip-protocol-flag",["^F",["^8G","^8H","^8I","^8J"]],"^7Z","Positional factory function for clojure.core.rrb-vector.rrbt/Transient."],"^8F",["^F",["^8G","^8H","^8I","^8J","^4Z"]],"^L","^3Z","^6","clojure/core/rrb_vector/rrbt.cljs","^:",19,"^77",["^1J",[["^8M","^7H","^8N","^8O","^8P"]]],"^78",null,"^79",["^1J",[null,null]],"^8",1,"^7:",false,"^8K","^8L","^7",1190,"^7D","^2F","^9",1190,"^7;",5,"^7<",true,"^72",["^1J",["^73",["^1J",[["^8M","^7H","^8N","^8O","^8P"]]]]],"^8Q",["^F",["^8G","^8H","^8I","^8J"]],"^7Z","Positional factory function for clojure.core.rrb-vector.rrbt/Transient."],"~$fallback-to-slow-splice-count1",["^ ","^L","^3Y","^6","clojure/core/rrb_vector/rrbt.cljs","^7",1075,"^8",1,"^9",1075,"^:",36,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",1075,"^8",6,"^9",1075,"^:",36],"^7>","^7?"],"~$RRBChunkedSeq",["^ ","~:num-fields",6,"^8F",["^F",["~$cljs.core/IEquiv","~$cljs.core/IHash","~$cljs.core/ASeq","~$cljs.core/ICollection","~$cljs.core/IChunkedNext","~$cljs.core/Object","~$cljs.core/IEmptyableCollection","~$cljs.core/ISeq","~$cljs.core/INext","~$cljs.core/ISeqable","~$cljs.core/IMeta","~$cljs.core/IPrintWithWriter","~$cljs.core/IChunkedSeq","~$cljs.core/ISequential","~$cljs.core/IWithMeta","~$cljs.core/IReduce"]],"^L","^4S","^6","clojure/core/rrb_vector/rrbt.cljs","^:",23,"~:type",true,"^8",10,"^7",41,"~:record",false,"^9",41,"^7>","~$function","^8Q",["^F",["^8U","^8V","^8W","^8X","^8Y","^8[","^90","^91","^92","^93","^94","^95","^96","^97","^98"]]],"~$count-vector-elements-beneath",["^ ","^71",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",960,"^8",7,"^9",960,"^:",36,"^72",["^1J",["^73",["^1J",[["^74","^7H"]]]]]],"^L","^2@","^6","clojure/core/rrb_vector/rrbt.cljs","^:",36,"^77",["^1J",[["^74","^7H"]]],"^78",null,"^79",["^1J",[null,null]],"^8",1,"^7:",false,"^7",960,"^7D",["^F",["^7F","^7I"]],"^9",960,"^7;",2,"^7<",true,"^72",["^1J",["^73",["^1J",[["^74","^7H"]]]]]],"~$subtree-branch-count",["^ ","^71",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",659,"^8",7,"^9",659,"^:",27,"^72",["^1J",["^73",["^1J",[["^74","^7H"]]]]]],"^L","^4E","^6","clojure/core/rrb_vector/rrbt.cljs","^:",27,"^77",["^1J",[["^74","^7H"]]],"^78",null,"^79",["^1J",[null,null]],"^8",1,"^7:",false,"^7",659,"^7D","^7I","^9",659,"^7;",2,"^7<",true,"^72",["^1J",["^73",["^1J",[["^74","^7H"]]]]]],"~$poor-branching?",["^ ","^71",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",1057,"^8",7,"^9",1057,"^:",22,"^72",["^1J",["^73",["^1J",[["~$v"]]]]]],"^L","^2H","^6","clojure/core/rrb_vector/rrbt.cljs","^:",22,"^77",["^1J",[["~$v"]]],"^78",null,"^79",["^1J",[null,null]],"^8",1,"^7:",false,"^7",1057,"^7D","^8>","^9",1057,"^7;",1,"^7<",true,"^72",["^1J",["^73",["^1J",[["~$v"]]]]]],"~$rrbt-concat-threshold",["^ ","^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",26,"^8",14,"^9",26,"^:",35,"~:const",true],"^L","^2L","^6","clojure/core/rrb_vector/rrbt.cljs","^:",35,"~:const-expr",["^ ","^O","^9@","~:val",33,"~:env",["^ ","~:context","~:expr"],"^1I",33,"^7>","^7I"],"^8",1,"^9@",true,"^7",26,"^9",26,"^7>","^7I"],"~$slice-right",["^ ","^71",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",133,"^8",7,"^9",133,"^:",18,"^72",["^1J",["^73",["^1J",[["^74","^7H","^8B"]]]]]],"^L","^2C","^6","clojure/core/rrb_vector/rrbt.cljs","^:",18,"^77",["^1J",[["^74","^7H","^8B"]]],"^78",null,"^79",["^1J",[null,null]],"^8",1,"^7:",false,"^7",133,"^7D","^8C","^9",133,"^7;",3,"^7<",true,"^72",["^1J",["^73",["^1J",[["^74","^7H","^8B"]]]]]],"~$max-extra-search-steps",["^ ","^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",27,"^8",14,"^9",27,"^:",36,"^9@",true],"^L","^51","^6","clojure/core/rrb_vector/rrbt.cljs","^:",36,"^9A",["^ ","^O","^9@","^9B",2,"^9C",["^ ","^9D","^9E"],"^1I",2,"^7>","^7I"],"^8",1,"^9@",true,"^7",27,"^9",27,"^7>","^7I"],"~$child-seq",["^ ","^71",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",739,"^8",7,"^9",739,"^:",16,"^72",["^1J",["^73",["^1J",[["^74","^7H","^8M"]]]]]],"^L","^2A","^6","clojure/core/rrb_vector/rrbt.cljs","^:",16,"^77",["^1J",[["^74","^7H","^8M"]]],"^78",null,"^79",["^1J",[null,null]],"^8",1,"^7:",false,"^7",739,"^7D","^7F","^9",739,"^7;",3,"^7<",true,"^72",["^1J",["^73",["^1J",[["^74","^7H","^8M"]]]]]],"~$IVecImpl",["^ ","^5",["^ ","^82",true,"^6","clojure/core/rrb_vector/rrbt.cljs","^:",22,"^8",14,"^7",29,"^83",["^ ","^7W",["^ ","~$-tail-offset",[["~$v"]],"~$-array-for",[["~$v","~$i"]]]],"^9",29,"^84",["^ ","~:-tail-offset",["^ ","^L","^9J","^72",["^1J",[["~$v"]]],"^7Z",null],"~:-array-for",["^ ","^L","^9K","^72",["^1J",[["~$v","~$i"]]],"^7Z",null]],"^86",["^1J",["@interface"]]],"^82",true,"^L","^4Z","^6","clojure/core/rrb_vector/rrbt.cljs","^:",22,"^8",1,"^7",29,"^83",["^ ","^7W",["^ ","^9J",[["~$v"]],"^9K",[["~$v","~$i"]]]],"^87",null,"^9",29,"^7>","^7F","^84",["^ ","^9L",["^ ","^L","^9J","^72",["^1J",[["~$v"]]],"^7Z",null],"^9M",["^ ","^L","^9K","^72",["^1J",[["~$v","~$i"]]],"^7Z",null]],"^88",["^F",["^2F","^4K"]],"^86",["^1J",["@interface"]]],"~$fallback-config",["^ ","^L","^2=","^6","clojure/core/rrb_vector/rrbt.cljs","^7",1074,"^8",1,"^9",1074,"^:",21,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",1074,"^8",6,"^9",1074,"^:",21],"^7>","^7?"],"~$last-non-nil-idx",["^ ","^71",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",952,"^8",7,"^9",952,"^:",23,"^72",["^1J",["^73",["^1J",[["~$arr"]]]]]],"^L","^2<","^6","clojure/core/rrb_vector/rrbt.cljs","^:",23,"^77",["^1J",[["^9P"]]],"^78",null,"^79",["^1J",[null,null]],"^8",1,"^7:",false,"^7",952,"^7D","^7I","^9",952,"^7;",1,"^7<",true,"^72",["^1J",["^73",["^1J",[["^9P"]]]]]],"~$->RRBChunkedSeq",["^ ","^71",null,"^5",["^ ","^8F",["^F",["^8U","^8V","^8W","^8X","^8Y","^8Z","^8[","^90","^91","^92","^93","^94","^95","^96","^97","^98"]],"^6","clojure/core/rrb_vector/rrbt.cljs","^:",23,"^8",10,"^8K","^8L","^7",41,"^9",41,"^72",["^1J",["^73",["^1J",[["^7R","^74","~$i","^7S","^7T","~$__hash"]]]]],"^8Q",["^F",["^8U","^8V","^8W","^8X","^8Y","^8[","^90","^91","^92","^93","^94","^95","^96","^97","^98"]],"^7Z","Positional factory function for clojure.core.rrb-vector.rrbt/RRBChunkedSeq."],"^8F",["^F",["^8U","^8V","^8W","^8X","^8Y","^8Z","^8[","^90","^91","^92","^93","^94","^95","^96","^97","^98"]],"^L","^2W","^6","clojure/core/rrb_vector/rrbt.cljs","^:",23,"^77",["^1J",[["^7R","^74","~$i","^7S","^7T","^9R"]]],"^78",null,"^79",["^1J",[null,null]],"^8",1,"^7:",false,"^8K","^8L","^7",41,"^7D","^4S","^9",41,"^7;",6,"^7<",true,"^72",["^1J",["^73",["^1J",[["^7R","^74","~$i","^7S","^7T","^9R"]]]]],"^8Q",["^F",["^8U","^8V","^8W","^8X","^8Y","^8[","^90","^91","^92","^93","^94","^95","^96","^97","^98"]],"^7Z","Positional factory function for clojure.core.rrb-vector.rrbt/RRBChunkedSeq."],"^9J",["^ ","^71",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",30,"^8",4,"^9",30,"^:",16,"^7Y","^4Z","^7Z",null,"^72",["^1J",["^73",["^1J",[["~$v"]]]]]],"^7Y","^4Z","^L","^2E","^6","clojure/core/rrb_vector/rrbt.cljs","^:",16,"^77",["^1J",[["~$v"]]],"^78",null,"^79",["^1J",[null,null]],"^8",1,"^7:",false,"^7",29,"^7D","^7F","^9",30,"^7;",1,"^7<",true,"^72",["^1J",["^73",["^1J",[["~$v"]]]]],"^7Z",null],"^9K",["^ ","^71",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",31,"^8",4,"^9",31,"^:",14,"^7Y","^4Z","^7Z",null,"^72",["^1J",["^73",["^1J",[["~$v","~$i"]]]]]],"^7Y","^4Z","^L","^4F","^6","clojure/core/rrb_vector/rrbt.cljs","^:",14,"^77",["^1J",[["~$v","~$i"]]],"^78",null,"^79",["^1J",[null,null]],"^8",1,"^7:",false,"^7",29,"^7D","^7F","^9",31,"^7;",2,"^7<",true,"^72",["^1J",["^73",["^1J",[["~$v","~$i"]]]]],"^7Z",null],"~$rebalance-leaves",["^ ","^71",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",680,"^8",7,"^9",680,"^:",23,"^72",["^1J",["^73",["^1J",[["^7K","^7L","^7M","^7N","^7O"]]]]]],"^L","^4N","^6","clojure/core/rrb_vector/rrbt.cljs","^:",23,"^77",["^1J",[["^7K","^7L","^7M","^7N","^7O"]]],"^78",null,"^79",["^1J",[null,null]],"^8",1,"^7:",false,"^7",680,"^7D","^7P","^9",680,"^7;",5,"^7<",true,"^72",["^1J",["^73",["^1J",[["^7K","^7L","^7M","^7N","^7O"]]]]]],"~$Vector",["^ ","^8T",6,"^8F",["^F",["~$cljs.core/IIndexed","~$cljs.core/IVector","~$cljs.core/IReversible","~$cljs.core/IKVReduce","^8U","^8V","~$cljs.core/IFn","^8X","~$cljs.core/IEditableCollection","^8Z","^39","^8[","^8G","~$clojure.core.rrb-vector.protocols/PSliceableVector","^92","^93","~$cljs.core/IStack","~$cljs.core/IMapEntry","^94","~$cljs.core/IComparable","^96","^97","~$cljs.core/IAssociative","~$clojure.core.rrb-vector.protocols/PSpliceableVector","^4Z","~$cljs.core/ILookup","^98"]],"^L","^4K","^6","clojure/core/rrb_vector/rrbt.cljs","^:",16,"^99",true,"^8",10,"^7",279,"^9:",false,"^9",279,"^7>","^9;","^8Q",["^F",["^9U","^9V","^9W","^9X","^8U","^8V","^9Y","^8X","^9Z","^8[","^8G","^92","^93","^:0","^:1","^94","^:2","^96","^97","^:3","^:5","^98"]]],"~$rebalance",["^ ","^71",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",756,"^8",7,"^9",756,"^:",16,"^72",["^1J",["^73",["^1J",[["^7H","^7K","^7L","^7M","^7N","^7O"]]]]]],"^L","^2Q","^6","clojure/core/rrb_vector/rrbt.cljs","^:",16,"^77",["^1J",[["^7H","^7K","^7L","^7M","^7N","^7O"]]],"^78",null,"^79",["^1J",[null,null]],"^8",1,"^7:",false,"^7",756,"^7D","^7P","^9",756,"^7;",6,"^7<",true,"^72",["^1J",["^73",["^1J",[["^7H","^7K","^7L","^7M","^7N","^7O"]]]]]],"~$fallback-to-slow-splice-if-needed",["^ ","^71",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",1078,"^8",7,"^9",1078,"^:",40,"^72",["^1J",["^73",["^1J",[["^7B","^7C","~$splice-result"]]]]]],"^L","^31","^6","clojure/core/rrb_vector/rrbt.cljs","^:",40,"^77",["^1J",[["^7B","^7C","^:8"]]],"^78",null,"^79",["^1J",[null,null]],"^8",1,"^7:",false,"^7",1078,"^7D",["^F",[null,"^7E","^7F"]],"^9",1078,"^7;",3,"^7<",true,"^72",["^1J",["^73",["^1J",[["^7B","^7C","^:8"]]]]]],"~$leaf-seq",["^ ","^71",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",677,"^8",7,"^9",677,"^:",15,"^72",["^1J",["^73",["^1J",[["^9P"]]]]]],"^L","^2:","^6","clojure/core/rrb_vector/rrbt.cljs","^:",15,"^77",["^1J",[["^9P"]]],"^78",null,"^79",["^1J",[null,null]],"^8",1,"^7:",false,"^7",677,"^7D","^7F","^9",677,"^7;",1,"^7<",true,"^72",["^1J",["^73",["^1J",[["^9P"]]]]]],"~$squash-nodes",["^ ","^71",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",877,"^8",7,"^9",877,"^:",19,"^72",["^1J",["^73",["^1J",[["^7H","^7K","^7L","^7M","^7N"]]]]]],"^L","^2B","^6","clojure/core/rrb_vector/rrbt.cljs","^:",19,"^77",["^1J",[["^7H","^7K","^7L","^7M","^7N"]]],"^78",null,"^79",["^1J",[null,null]],"^8",1,"^7:",false,"^7",877,"^7D","^7P","^9",877,"^7;",5,"^7<",true,"^72",["^1J",["^73",["^1J",[["^7H","^7K","^7L","^7M","^7N"]]]]]],"~$Transient",["^ ","^8T",5,"^8F",["^F",["^8G","^8H","^8I","^8J","^4Z"]],"^L","^2F","^6","clojure/core/rrb_vector/rrbt.cljs","^:",19,"^99",true,"^8",10,"^7",1190,"^9:",false,"^9",1190,"^7>","^9;","^8Q",["^F",["^8G","^8H","^8I","^8J"]]],"~$splice-rrbts",["^ ","^71",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",1185,"^8",7,"^9",1185,"^:",19,"^72",["^1J",["^73",["^1J",[["^7B","^7C"]]]]]],"^L","^3>","^6","clojure/core/rrb_vector/rrbt.cljs","^:",19,"^77",["^1J",[["^7B","^7C"]]],"^78",null,"^79",["^1J",[null,null]],"^8",1,"^7:",false,"^7",1185,"^7D",["^F",[null,"^7E","^7F"]],"^9",1185,"^7;",2,"^7<",true,"^72",["^1J",["^73",["^1J",[["^7B","^7C"]]]]]],"~$->Vector",["^ ","^71",null,"^5",["^ ","^8F",["^F",["^9U","^9V","^9W","^9X","^8U","^8V","^9Y","^8X","^9Z","^8Z","^39","^8[","^8G","^9[","^92","^93","^:0","^:1","^94","^:2","^96","^97","^:3","^:4","^4Z","^:5","^98"]],"^6","clojure/core/rrb_vector/rrbt.cljs","^:",16,"^8",10,"^8K","^8L","^7",279,"^9",279,"^72",["^1J",["^73",["^1J",[["^8M","^7H","^8N","^8O","^7T","^9R"]]]]],"^8Q",["^F",["^9U","^9V","^9W","^9X","^8U","^8V","^9Y","^8X","^9Z","^8[","^8G","^92","^93","^:0","^:1","^94","^:2","^96","^97","^:3","^:5","^98"]],"^7Z","Positional factory function for clojure.core.rrb-vector.rrbt/Vector."],"^8F",["^F",["^9U","^9V","^9W","^9X","^8U","^8V","^9Y","^8X","^9Z","^8Z","^39","^8[","^8G","^9[","^92","^93","^:0","^:1","^94","^:2","^96","^97","^:3","^:4","^4Z","^:5","^98"]],"^L","^2>","^6","clojure/core/rrb_vector/rrbt.cljs","^:",16,"^77",["^1J",[["^8M","^7H","^8N","^8O","^7T","^9R"]]],"^78",null,"^79",["^1J",[null,null]],"^8",1,"^7:",false,"^8K","^8L","^7",279,"^7D","^4K","^9",279,"^7;",6,"^7<",true,"^72",["^1J",["^73",["^1J",[["^8M","^7H","^8N","^8O","^7T","^9R"]]]]],"^8Q",["^F",["^9U","^9V","^9W","^9X","^8U","^8V","^9Y","^8X","^9Z","^8[","^8G","^92","^93","^:0","^:1","^94","^:2","^96","^97","^:3","^:5","^98"]],"^7Z","Positional factory function for clojure.core.rrb-vector.rrbt/Vector."]],"^[",["^ ","^D","^D","^W","^W"],"~:cljs.analyzer/constants",["^ ","^Y",["^F",["~$i","~:else","^7H","^9R","^7T","^7R","~:debug-fn","^8M","^74","~:mutable","^8N","^8O","^7S","^8P"]],"~:order",["^7R","^74","~$i","^7S","^7T","^9R","^:A","^:?","^8M","^7H","^8N","^8O","^:@","^8P"]],"^1O",["^ ","^Z",["^F",[]],"^[",["^F",[]]],"^1P",[],"^1Q",["^X","^W","^S","^T","^U","^V"]],"^P","^M","~:ns-specs",["^ "],"~:ns-spec-vars",["^F",[]],"~:compiler-options",["^54",[["^:E","~:static-fns"],true,["~:js-options","~:use-babel"],null,["^:E","~:shadow-tweaks"],null,["^:E","~:source-map-inline"],null,["^:E","~:shadow-optimize-constants"],null,["^:E","~:elide-asserts"],false,["^:E","~:optimize-constants"],null,["^:E","^1V"],null,["^:E","~:external-config"],null,["^:E","~:tooling-config"],null,["^:E","~:emit-constants"],null,["^:E","~:load-tests"],true,["^:E","~:form-size-threshold"],null,["^:E","~:global-goog-object&array"],null,["^:E","~:data-readers"],null,["~:shadow.build/config","~:target"],"~:karma",["^:E","~:infer-externs"],"~:auto",["^:E","^1X"],null,["^:G","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^:E","~:fn-invoke-direct"],null,["^:E","~:source-map"],true]]]